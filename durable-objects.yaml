- title: Cloudflare Durable Objects · Cloudflare Durable Objects docs
  content: |-
    # Cloudflare Durable Objects · Cloudflare Durable Objects docs

    Create collaborative applications, real-time chat, multiplayer games and more without needing to coordinate state or manage infrastructure.

    Available on Paid plans

    Durable Objects provide a powerful compute API for coordinating multiple clients or users. Each Durable Object has private, transactional and strongly consistent storage attached.

    Use Durable Objects to build collaborative editing tools, interactive chat, multiplayer games and applications that need coordination among multiple clients, without requiring you to build serialization and coordination primitives on your own.

    [Get started](/durable-objects/get-started/walkthrough/)

    ---

    ## Features

    ### In-memory State

    Learn how Durable Objects coordinate connections among multiple clients or events.

    ### Storage API

    Learn how Durable Objects provide transactional, strongly consistent, and serializable storage.

    ### WebSocket Hibernation

    Learn how WebSocket Hibernation allows you to manage the connections of multiple clients at scale.

    ### Durable Objects Alarms

    Learn how to use alarms to trigger a Durable Object and perform compute in the future at customizable intervals.

    ---

    **[Workers](/workers/)**

    Cloudflare Workers provides a serverless execution environment that allows you to create new applications or augment existing ones without configuring or maintaining infrastructure.

    **[D1](/d1/)**

    D1 is Cloudflare’s SQL-based native serverless database. Create a database by importing data or defining your tables and writing your queries within a Worker or through the API.

    **[R2](/r2/)**

    Cloudflare R2 Storage allows developers to store large amounts of unstructured data without the costly egress bandwidth fees associated with typical cloud storage services.

    ---

    ## More resources

    [Built with Durable Objects](https://workers.cloudflare.com/built-with/collections/durable-objects/)

    Browse what other developers are building with Durable Objects.

    [Limits](/durable-objects/platform/limits/)

    Learn about Durable Objects limits.

    [Pricing](/durable-objects/platform/pricing/)

    Learn about Durable Objects pricing.

    [Storage options](/workers/platform/storage-options/)

    Learn more about storage and database options you can build with Workers.

    [Developer Discord](https://discord.cloudflare.com/)

    Connect with the Workers community on Discord to ask questions, show what you are building, and discuss the platform with other developers.

    [@CloudflareDev](https://x.com/cloudflaredev)

    Follow @CloudflareDev on Twitter to learn about product announcements, and what is new in Cloudflare Developer Platform.

    ## Thank you for helping improve Cloudflare's documentation!
- title: Walkthrough · Cloudflare Durable Objects docs
  content: |-
    # Walkthrough · Cloudflare Durable Objects docs

    This guide will instruct you through:

    -   Writing a Durable Object class.
    -   Writing a Worker which invokes methods on a Durable Object.
    -   Deploying a Durable Object.

    ## Prerequisites

    1.  Sign up for a [Cloudflare account ↗](https://dash.cloudflare.com/sign-up/workers-and-pages).
    2.  Install [`Node.js` ↗](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).

    Node.js version manager

    Use a Node version manager like [Volta ↗](https://volta.sh/) or [nvm ↗](https://github.com/nvm-sh/nvm) to avoid permission issues and change Node.js versions. [Wrangler](/workers/wrangler/install-and-update/), discussed later in this guide, requires a Node version of `16.17.0` or later.

    ## 1\. Enable Durable Objects in the dashboard

    To enable Durable Objects, you will need to purchase the Workers Paid plan:

    1.  Log in to the [Cloudflare dashboard ↗](https://dash.cloudflare.com/), and select your account.
    2.  Go to **Workers & Pages** > **Plans**.
    3.  Select **Purchase Workers Paid** and complete the payment process to enable Durable Objects.

    ## 2\. Create a Worker project

    Durable Objects are accessed from a [Worker](/workers/).

    To create a Worker project, run:

    -   [npm](#tab-panel-1516)
    -   [yarn](#tab-panel-1517)
    -   [pnpm](#tab-panel-1518)

    ```
    npm create cloudflare@latest -- durable-object-starter
    ```

    Running `create cloudflare@latest` will install [Wrangler](/workers/wrangler/install-and-update/), the Workers CLI. You will use Wrangler to test and deploy your project.

    For setup, select the following options:

    -   For _What would you like to start with?_, choose `Hello World example`.
    -   For _Which template would you like to use?_, choose `Hello World Worker using Durable Objects`.
    -   For _Which language do you want to use?_, choose `JavaScript / TypeScript`.
    -   For _Do you want to use git for version control?_, choose `Yes`.
    -   For _Do you want to deploy your application?_, choose `No` (we will be making some changes before deploying).

    This will create a new directory, which will include either a `src/index.js` or `src/index.ts` file to write your code and a [`wrangler.toml`](/workers/wrangler/configuration/) configuration file.

    Move into your new directory:

    ```
    cd durable-object-starter
    ```

    ## 3\. Write a Durable Object class

    Durable Objects are defined by a exporting a standard JavaScript class which extends from the `DurableObject` base class.

    Your `MyDurableObject` class will have a constructor with two parameters. The first parameter, `state`, passed to the class constructor contains state specific to the Durable Object, including methods for accessing storage. The second parameter, `env`, contains any bindings you have associated with the Worker when you uploaded it.

    -   [JavaScript](#tab-panel-1504)
    -   [TypeScript](#tab-panel-1505)

    ```
    import { DurableObject } from "cloudflare:workers";export class MyDurableObject extends DurableObject {  constructor(state, env) {}}
    ```

    Workers can invoke public methods defined on a Durable Object via Remote Procedure Call (RPC).

    The `sayHello` method demonstrates this capability:

    -   [JavaScript](#tab-panel-1506)
    -   [TypeScript](#tab-panel-1507)

    ```
    import { DurableObject } from "cloudflare:workers";export class MyDurableObject extends DurableObject {  constructor(state, env) {}  async sayHello() {    return "Hello, World!";  }}
    ```

    ## 4\. Invoke methods on a Durable Object class

    As mentioned previously, methods on a Durable Object class are invoked by a Worker. This is done by creating an ID refering to an instance of the Durable Object class, getting a stub that refers to a particular instance of a Durable Object class, and invoking methods on that stub.

    The fetch handler should look like the following:

    -   [JavaScript](#tab-panel-1508)
    -   [TypeScript](#tab-panel-1509)

    ```
    // Workerexport default {  async fetch(request, env) {    // Every unique ID refers to an individual instance of the Durable Object class    const id = env.MY_DURABLE_OBJECT.idFromName("foo");    // A stub is a client used to invoke methods on the Durable Object    const stub = env.MY_DURABLE_OBJECT.get(id);    // Methods on the Durable Object are invoked via the stub    const rpcResponse = await stub.sayHello();    return new Response(rpcResponse);  },};
    ```

    ## 5\. Configure Durable Object bindings

    To allow a Worker to invoke methods on a Durable Object, the Worker must have a [Durable Object binding](/workers/runtime-apis/bindings/) in the project's [`wrangler.toml`](about:/workers/wrangler/configuration/#durable-objects) file. The binding is configured to use a particular Durable Object class.

    -   [wrangler.toml](#tab-panel-1519)
    -   [wrangler.json](#tab-panel-1520)

    ```
    [[durable_objects.bindings]]name = "MY_DURABLE_OBJECT"class_name = "MyDurableObject"
    ```

    The `[[durable_objects.bindings]]` section contains the following fields:

    -   `name` - Required. The binding name to use within your Worker.
    -   `class_name` - Required. The class name you wish to bind to.
    -   `script_name` - Optional. The name of the Worker if the Durable Object is external to this Worker.
    -   `environment` - Optional. The environment of the `script_name` to bind to.

    Refer to [Wrangler Configuration](about:/workers/wrangler/configuration/#durable-objects) for more detail.

    ## 6\. Configure Durable Object classes with migrations

    A migration is a mapping process from a class name to a runtime state. You perform a migration when creating a new Durable Object class, or when renaming, deleting or transferring an existing Durable Object class.

    Migrations are performed through the `[[migrations]]` configurations key in your `wrangler.toml` file.

    The Durable Object migration to create a new Durable Object class will look like the following in your Worker's `wrangler.toml` file:

    -   [wrangler.toml](#tab-panel-1521)
    -   [wrangler.json](#tab-panel-1522)

    ```
    [[migrations]]tag = "v1" # Should be unique for each entrynew_classes = ["MyDurableObject"] # Array of new classes
    ```

    ### 6.a Optional: Configure new Durable Object class for SQL storage

    A Durable Object class can only have a single storage type, which cannot be changed after the Durable Object class is created.

    To configure SQL storage and API, replace `new_classes` with `new_sqlite_classes` in your Worker's `wrangler.toml` file:

    -   [wrangler.toml](#tab-panel-1523)
    -   [wrangler.json](#tab-panel-1524)

    ```
    [[migrations]]tag = "v1" # Should be unique for each entrynew_sqlite_classes = ["MyDurableObject"] # Array of new classes
    ```

    Refer to [Durable Objects migrations](/durable-objects/reference/durable-objects-migrations/) to learn more about the migration process.

    ## 7\. Develop a Durable Object Worker locally

    To test your Durable Object locally, run [`wrangler dev`](about:/workers/wrangler/commands/#dev):

    In your console, you should see a`Hello world` string returned by the Durable Object.

    ## 8\. Deploy your Durable Object Worker

    To deploy your Durable Object Worker:

    Once deployed, you should be able to see your newly created Durable Object Worker on the [Cloudflare dashboard ↗](https://dash.cloudflare.com/), **Workers & Pages** > **Overview**.

    Preview your Durable Object Worker at `<YOUR_WORKER>.<YOUR_SUBDOMAIN>.workers.dev`.

    By finishing this tutorial, you have successfully created, tested and deployed a Durable Object.

    -   [Send requests to Durable Objects](/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/)
    -   [Miniflare ↗](https://github.com/cloudflare/workers-sdk/tree/main/packages/miniflare) - Helpful tools for mocking and testing your Durable Objects.

    ## Thank you for helping improve Cloudflare's documentation!
- title: Tutorial with SQL API · Cloudflare Durable Objects docs
  content: |-
    # Tutorial with SQL API · Cloudflare Durable Objects docs

    This guide will instruct you through:

    -   Writing a JavaScript class that defines a Durable Object.
    -   Using Durable Objects SQL API to query a Durable Object's private, embedded SQLite database.
    -   Instantiating and communicating with a Durable Object from another Worker.
    -   Deploying a Durable Object and a Worker that communicates with a Durable Object.

    ## Prerequisites

    1.  Sign up for a [Cloudflare account ↗](https://dash.cloudflare.com/sign-up/workers-and-pages).
    2.  Install [`Node.js` ↗](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).

    Node.js version manager

    Use a Node version manager like [Volta ↗](https://volta.sh/) or [nvm ↗](https://github.com/nvm-sh/nvm) to avoid permission issues and change Node.js versions. [Wrangler](/workers/wrangler/install-and-update/), discussed later in this guide, requires a Node version of `16.17.0` or later.

    ## 1\. Enable Durable Objects in the dashboard

    To enable Durable Objects, you will need to purchase the Workers Paid plan:

    1.  Log in to the [Cloudflare dashboard ↗](https://dash.cloudflare.com/), and select your account.
    2.  Go to **Workers & Pages** > **Plans**.
    3.  Select **Purchase Workers Paid** and complete the payment process to enable Durable Objects.

    ## 2\. Create a Worker project to access Durable Objects

    You will access your Durable Object from a [Worker](/workers/). Your Worker application is an interface to interact with your Durable Object.

    To create a Worker project, run:

    -   [npm](#tab-panel-1477)
    -   [yarn](#tab-panel-1478)
    -   [pnpm](#tab-panel-1479)

    ```
    npm create cloudflare@latest -- durable-object-starter
    ```

    Running `create cloudflare@latest` will install [Wrangler](/workers/wrangler/install-and-update/), the Workers CLI. You will use Wrangler to test and deploy your project.

    For setup, select the following options:

    -   For _What would you like to start with?_, choose `Hello World example`.
    -   For _Which template would you like to use?_, choose `Hello World Worker Using Durable Objects`.
    -   For _Which language do you want to use?_, choose `TypeScript`.
    -   For _Do you want to use git for version control?_, choose `Yes`.
    -   For _Do you want to deploy your application?_, choose `No` (we will be making some changes before deploying).

    This will create a new directory, which will include either a `src/index.js` or `src/index.ts` file to write your code and a [`wrangler.toml`](/workers/wrangler/configuration/) configuration file.

    Move into your new directory:

    ```
    cd durable-object-starter
    ```

    ## 3\. Write a class to define a Durable Object that uses SQL API

    Before you create and access a Durable Object, its behavior must be defined by an ordinary exported JavaScript class.

    Your `MyDurableObject` class will have a constructor with two parameters. The first parameter, `ctx`, passed to the class constructor contains state specific to the Durable Object, including methods for accessing storage. The second parameter, `env`, contains any bindings you have associated with the Worker when you uploaded it.

    -   [JavaScript](#tab-panel-1465)
    -   [TypeScript](#tab-panel-1466)

    ```
    export class MyDurableObject extends DurableObject {  constructor(ctx, env) {}}
    ```

    Workers communicate with a Durable Object using [remote-procedure call](about:/workers/runtime-apis/rpc/#_top). Public methods on a Durable Object class are exposed as [RPC methods](/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/) to be called by another Worker.

    Your file should now look like:

    -   [JavaScript](#tab-panel-1467)
    -   [TypeScript](#tab-panel-1468)

    ```
    export class MyDurableObject extends DurableObject {  constructor(ctx: DurableObjectState, env: Env) {}  async sayHello() {    let result = this.ctx.storage.sql      .exec("SELECT 'Hello, World!' as greeting")      .one();    return result.greeting;  }}
    ```

    In the code above, you have:

    1.  Defined a RPC method, `sayHello()`, that can be called by a Worker to communicate with a Durable Object.
    2.  Accessed a Durable Object's attached storage, which is a private SQLite database only accesible to the object, using [SQL API](about:/durable-objects/api/sql-storage/#exec) methods (`sql.exec()`) available on `ctx.storage` .
    3.  Returned an object representing the single row query result using `one()`, which checks that the query result has exactly one row.
    4.  Return the `greeting` column from the row object result.

    ## 4\. Instantiate and communicate with a Durable Object

    A Worker is used to [access Durable Objects](/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/).

    To communicate with a Durable Object, the Worker's fetch handler should look like the following:

    -   [JavaScript](#tab-panel-1469)
    -   [TypeScript](#tab-panel-1470)

    ```
    export default {  async fetch(request, env) {    let id = env.MY_DURABLE_OBJECT.idFromName(new URL(request.url).pathname);    let stub = env.MY_DURABLE_OBJECT.get(id);    let greeting = await stub.sayHello();    return new Response(greeting);  },};
    ```

    In the code above, you have:

    1.  Exported your Worker's main event handlers, such as the `fetch()` handler for receiving HTTP requests.
    2.  Passed `env` into the `fetch()` handler. Bindings are delivered as a property of the environment object passed as the second parameter when an event handler or class constructor is invoked. By calling the `idFromName()` function on the binding, you use a string-derived object ID. You can also ask the system to [generate random unique IDs](about:/durable-objects/api/namespace/#newuniqueid). System-generated unique IDs have better performance characteristics, but require you to store the ID somewhere to access the Object again later.
    3.  Derived an object ID from the URL path. `MY_DURABLE_OBJECT.idFromName()` always returns the same ID when given the same string as input (and called on the same class), but never the same ID for two different strings (or for different classes). In this case, you are creating a new object for each unique path.
    4.  Constructed the stub for the Durable Object using the ID. A stub is a client object used to send messages to the Durable Object.
    5.  Called a Durable Object by invoking a RPC method, `sayHello()`, on the Durable Object, which returns a `Hello, World!` string greeting.
    6.  Received an HTTP response back to the client by constructing a HTTP Response with `return new Response()`.

    Refer to [Access a Durable Object from a Worker](/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/) to learn more about communicating with a Durable Object.

    ## 5\. Configure Durable Object bindings

    [Bindings](/workers/runtime-apis/bindings/) allow your Workers to interact with resources on the Cloudflare developer platform. The Durable Object bindings in your Worker project's `wrangler.toml` will include a binding name (for this guide, use `MY_DURABLE_OBJECT`) and the class name (`MyDurableObject`).

    -   [wrangler.toml](#tab-panel-1480)
    -   [wrangler.json](#tab-panel-1481)

    ```
    [[durable_objects.bindings]]name = "MY_DURABLE_OBJECT"class_name = "MyDurableObject"
    ```

    The `[[durable_objects.bindings]]` section contains the following fields:

    -   `name` - Required. The binding name to use within your Worker.
    -   `class_name` - Required. The class name you wish to bind to.
    -   `script_name` - Optional. Defaults to the current [environment's](/durable-objects/reference/environments/) Worker code.

    ## 6\. Configure Durable Object class with SQLite storage backend

    A migration is a mapping process from a class name to a runtime state. You perform a migration when creating a new Durable Object class, or when renaming, deleting or transferring an existing Durable Object class.

    Migrations are performed through the `[[migrations]]` configurations key in your `wrangler.toml` file.

    The Durable Object migration to create a new Durable Object class with SQLite storage backend will look like the following in your Worker's `wrangler.toml` file:

    -   [wrangler.toml](#tab-panel-1482)
    -   [wrangler.json](#tab-panel-1483)

    ```
    [[migrations]]tag = "v1" # Should be unique for each entrynew_sqlite_classes = ["MyDurableObject"] # Array of new classes
    ```

    Refer to [Durable Objects migrations](/durable-objects/reference/durable-objects-migrations/) to learn more about the migration process.

    ## 7\. Develop a Durable Object Worker locally

    To test your Durable Object locally, run [`wrangler dev`](about:/workers/wrangler/commands/#dev):

    In your console, you should see a`Hello world` string returned by the Durable Object.

    ## 8\. Deploy your Durable Object Worker

    To deploy your Durable Object Worker:

    Once deployed, you should be able to see your newly created Durable Object Worker on the [Cloudflare dashboard ↗](https://dash.cloudflare.com/), **Workers & Pages** > **Overview**.

    Preview your Durable Object Worker at `<YOUR_WORKER>.<YOUR_SUBDOMAIN>.workers.dev`.

    By finishing this tutorial, you have successfully created, tested and deployed a Durable Object.

    -   [Create Durable Object stubs](/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/)
    -   [Access Durable Objects Storage](/durable-objects/best-practices/access-durable-objects-storage/)
    -   [Miniflare ↗](https://github.com/cloudflare/workers-sdk/tree/main/packages/miniflare) - Helpful tools for mocking and testing your Durable Objects.

    ## Thank you for helping improve Cloudflare's documentation!
- title: Video series · Cloudflare Durable Objects docs
  content: >-
    # Video series · Cloudflare Durable Objects docs


    Building stateful apps on a serverless architecture has been difficult until
    Cloudflare's Durable Objects - a powerful API that enables you to easily
    build stateful serverless apps on Workers. In this series of videos, we will
    show how Durable Objects work and start building a video call app together.


    ## Thank you for helping improve Cloudflare's documentation!
- title: Introduction · Cloudflare Durable Objects docs
  content: >-
    # Introduction · Cloudflare Durable Objects docs


    In this episode, we will present an overview of the final project, discuss
    its underlying architecture, and access resources to set up the project
    locally.


    ## Thank you for helping improve Cloudflare's documentation!
- title: What are Durable Objects? · Cloudflare Durable Objects docs
  content: >-
    # What are Durable Objects? · Cloudflare Durable Objects docs


    In this video, we will show how Durable Objects work and start building a
    video call app together.


    ## Thank you for helping improve Cloudflare's documentation!
- title: Create a Serverless Websocket 'Backend' · Cloudflare Durable Objects docs
  content: >-
    # Create a Serverless Websocket 'Backend' · Cloudflare Durable Objects docs


    In this video, we'll create a WebSocket backend using serverless technology,
    making the process simpler than ever before. You'll learn how to create your
    first Durable Object, set up a WebSocket server to coordinate connections,
    and keep track of connected clients.


    ## Thank you for helping improve Cloudflare's documentation!
- title: Real-time messaging with WebSockets · Cloudflare Durable Objects docs
  content: >-
    # Real-time messaging with WebSockets · Cloudflare Durable Objects docs


    Now, we'll take it a step further by enabling our server to receive and
    broadcast messages. In this video, you'll learn how to route and broadcast
    incoming messages from WebSocket connections and implement error handling
    such as closed WebSocket connections. By the end, you will have completed
    the backend for our video call app.


    ## Thank you for helping improve Cloudflare's documentation!
- title: Building the App Frontend and UI · Cloudflare Durable Objects docs
  content: >-
    # Building the App Frontend and UI · Cloudflare Durable Objects docs


    Now, we're moving to the frontend. In this video, we'll set up the frontend
    starter code (the starter code is located in the Veet GitHub repository),
    connect to Durable Objects using a call room ID, and display a local video
    preview.


    ## Thank you for helping improve Cloudflare's documentation!
- title: Make and Answer WebRTC calls · Cloudflare Durable Objects docs
  content: >-
    # Make and Answer WebRTC calls · Cloudflare Durable Objects docs


    In this video, we'll build on the frontend we set up earlier by adding
    functionality for making and answering WebRTC video calls. You'll learn how
    to create peer-to-peer connections, handle ICE candidates, and seamlessly
    send and receive video streams between users.


    ## Thank you for helping improve Cloudflare's documentation!
- title: Invoking methods · Cloudflare Durable Objects docs
  content: |-
    # Invoking methods · Cloudflare Durable Objects docs

    ## Invoking methods on a Durable Object

    All new projects and existing projects with a compatibility date greater than or equal to [`2024-04-03`](about:/workers/configuration/compatibility-flags/#durable-object-stubs-and-service-bindings-support-rpc) should prefer to invoke [Remote Procedure Call (RPC)](/workers/runtime-apis/rpc/) methods defined on a Durable Object class. Legacy projects can continue to invoke the `fetch` handler on the Durable Object class indefinitely.

    ### Invoke RPC methods

    By writing a Durable Object class which inherits from the built-in type `DurableObject`, public methods on the Durable Objects class are exposed as [RPC methods](/workers/runtime-apis/rpc/), which you can call using a [DurableObjectStub](/durable-objects/api/stub) from a Worker.

    All RPC calls are [asynchronous](/workers/runtime-apis/rpc/lifecycle/), accept and return [serializable types](/workers/runtime-apis/rpc/), and [propagate exceptions](/workers/runtime-apis/rpc/error-handling/) to the caller without a stack trace. Refer to [Workers RPC](/workers/runtime-apis/rpc/) for complete details.

    -   [JavaScript](#tab-panel-1385)
    -   [TypeScript](#tab-panel-1386)

    ```
    import { DurableObject } from "cloudflare:workers";// Durable Objectexport class MyDurableObject extends DurableObject {  constructor(ctx, env) {    super(ctx, env);  }  async sayHello() {    return "Hello, World!";  }}// Workerexport default {  async fetch(request, env) {    // Every unique ID refers to an individual instance of the Durable Object class    const id = env.MY_DURABLE_OBJECT.idFromName("foo");    // A stub is a client used to invoke methods on the Durable Object    const stub = env.MY_DURABLE_OBJECT.get(id);    // Methods on the Durable Object are invoked via the stub    const rpcResponse = await stub.sayHello();    return new Response(rpcResponse);  },};
    ```

    Refer to [Build a Counter](/durable-objects/examples/build-a-counter/) for a complete example.

    ### Invoking the `fetch` handler

    If your project is stuck on a compatibility date before [`2024-04-03`](about:/workers/configuration/compatibility-flags/#durable-object-stubs-and-service-bindings-support-rpc), or has the need to send a [`Request`](/workers/runtime-apis/request/) object and return a `Response` object, then you should send requests to a Durable Object via the fetch handler.

    -   [JavaScript](#tab-panel-1381)
    -   [TypeScript](#tab-panel-1382)

    ```
    import { DurableObject } from "cloudflare:workers";// Durable Objectexport class MyDurableObject extends DurableObject {  constructor(ctx, env) {    super(ctx, env);  }  async fetch(request) {    return new Response("Hello, World!");  }}// Workerexport default {  async fetch(request, env) {    // Every unique ID refers to an individual instance of the Durable Object class    const id = env.MY_DURABLE_OBJECT.idFromName("foo");    // A stub is a client used to invoke methods on the Durable Object    const stub = env.MY_DURABLE_OBJECT.get(id);    // Methods on the Durable Object are invoked via the stub    const response = await stub.fetch(request);    return response;  },};
    ```

    The `URL` associated with the [`Request`](/workers/runtime-apis/request/) object passed to the `fetch()` handler of your Durable Object must be a well-formed URL, but does not have to be a publicly-resolvable hostname.

    Without RPC, customers frequently construct requests which corresponded to private methods on the Durable Object and dispatch requests from the `fetch` handler. RPC is obviously more ergonomic in this example.

    -   [JavaScript](#tab-panel-1383)
    -   [TypeScript](#tab-panel-1384)

    ```
    import { DurableObject } from "cloudflare:workers";// Durable Objectexport class MyDurableObject extends DurableObject {  constructor(ctx: DurableObjectState, env: Env) {    super(ctx, env);  }  private hello(name) {    return new Response(`Hello, ${name}!`);  }  private goodbye(name) {    return new Response(`Goodbye, ${name}!`);  }  async fetch(request) {    const url = new URL(request.url);    let name = url.searchParams.get("name");    if (!name) {      name = "World";    }    switch (url.pathname) {      case "/hello":        return this.hello(name);      case "/goodbye":        return this.goodbye(name);      default:        return new Response("Bad Request", { status: 400 });    }  }}// Workerexport default {  async fetch(_request, env, _ctx) {    // Every unique ID refers to an individual instance of the Durable Object class    const id = env.MY_DURABLE_OBJECT.idFromName("foo");    // A stub is a client used to invoke methods on the Durable Object    const stub = env.MY_DURABLE_OBJECT.get(id);    // Invoke the fetch handler on the Durable Object stub    let response = await stub.fetch("http://do/hello?name=World");    return response;  },};
    ```

    ## Thank you for helping improve Cloudflare's documentation!
- title: Access Durable Objects Storage · Cloudflare Durable Objects docs
  content: |-
    # Access Durable Objects Storage · Cloudflare Durable Objects docs

    Durable Objects are a powerful compute API that provides a compute with storage building block. Each Durable Object has its own private, transactional and strongly consistent storage. Durable Objects Storage API provides access to a Durable Object's attached storage.

    A Durable Object's [in-memory state](/durable-objects/reference/in-memory-state/) is preserved as long as the Durable Object is not evicted from memory. Inactive Durable Objects with no incoming request traffic can be evicted. There are normal operations like [code deployments](/workers/configuration/versions-and-deployments/) that trigger Durable Objects to restart and lose their in-memory state. For these reasons, you should use Storage API to persist state durably on disk that needs to survive eviction or restart of Durable Objects.

    ## Access storage

    By default, a Durable Object class leverages a key-value storage backend. New Durable Object classes can opt-in to using a [SQLite storage backend](about:/durable-objects/best-practices/access-durable-objects-storage/#sqlite-storage-backend).

    [Storage API methods](about:/durable-objects/api/storage-api/#methods) are available on `ctx.storage` parameter passed to the Durable Object constructor. Storage API has key-value APIs and SQL APIs. Only Durable Object classes with a SQLite storage backend can access SQL API.

    A common pattern is to initialize a Durable Object from [persistent storage](/durable-objects/api/storage-api/) and set instance variables the first time it is accessed. Since future accesses are routed to the same Durable Object, it is then possible to return any initialized values without making further calls to persistent storage.

    ```
    import { DurableObject } from "cloudflare:workers";export class Counter extends DurableObject {  value: number;  constructor(ctx: DurableObjectState, env: Env) {    super(ctx, env);    // `blockConcurrencyWhile()` ensures no requests are delivered until    // initialization completes.    ctx.blockConcurrencyWhile(async () => {      // After initialization, future reads do not need to access storage.      this.value = (await ctx.storage.get("value")) || 0;    });  }  async getCounterValue() {    return this.value;  }}
    ```

    ### Removing a Durable Object's storage

    A Durable Object fully ceases to exist if, when it shuts down, its storage is empty. If you never write to a Durable Object's storage at all (including setting alarms), then storage remains empty, and so the Durable Object will no longer exist once it shuts down.

    However if you ever write using [Storage API](/durable-objects/api/storage-api/), including setting alarms, then you must explicitly call [`storage.deleteAll()`](about:/durable-objects/api/storage-api/#deleteall) to empty storage. It is not sufficient to simply delete the specific data that you wrote, such as deleting a key or dropping a table, as some metadata may remain. The only way to remove all storage is to call `deleteAll()`. Calling `deleteAll()` ensures that a Durable Object will not be billed for storage.

    ## SQLite storage backend

    To allow a new Durable Object class to use SQLite storage backend, use `new_sqlite_classes` on the migration in your Worker's `wrangler.toml` file:

    -   [wrangler.toml](#tab-panel-1375)
    -   [wrangler.json](#tab-panel-1376)

    ```
    [[migrations]]tag = "v1" # Should be unique for each entrynew_sqlite_classes = ["MyDurableObject"] # Array of new classes
    ```

    [SQL API](about:/durable-objects/api/sql-storage/#exec) is available on `ctx.storage.sql` parameter passed to the Durable Object constructor.

    ### Examples

    [SQL API](about:/durable-objects/api/sql-storage/#exec) examples below use the following SQL schema:

    ```
    import { DurableObject } from "cloudflare:workers";export class MyDurableObject extends DurableObject {  sql: SqlStorage  constructor(ctx: DurableObjectState, env: Env) {    super(ctx, env);    this.sql = ctx.storage.sql;    this.sql.exec(`CREATE TABLE IF NOT EXISTS artist(      artistid    INTEGER PRIMARY KEY,      artistname  TEXT    );INSERT INTO artist (artistid, artistname) VALUES      (123, 'Alice'),      (456, 'Bob'),      (789, 'Charlie');`    );  }}
    ```

    Iterate over query results as row objects:

    ```
      let cursor = this.sql.exec("SELECT * FROM artist;");  for (let row of cursor) {    // Iterate over row object and do something  }
    ```

    Convert query results to an array of row objects:

    ```
      // Return array of row objects: [{"artistid":123,"artistname":"Alice"},{"artistid":456,"artistname":"Bob"},{"artistid":789,"artistname":"Charlie"}]  let resultsArray1 = this.sql.exec("SELECT * FROM artist;").toArray();  // OR  let resultsArray2 = Array.from(this.sql.exec("SELECT * FROM artist;"));  // OR  let resultsArray3 = [...this.sql.exec("SELECT * FROM artist;")]; // JavaScript spread syntax
    ```

    Convert query results to an array of row values arrays:

    ```
      // Returns [[123,"Alice"],[456,"Bob"],[789,"Charlie"]]  let cursor = this.sql.exec("SELECT * FROM artist;");  let resultsArray = cursor.raw().toArray();  // Returns ["artistid","artistname"]  let columnNameArray = this.sql.exec("SELECT * FROM artist;").columnNames.toArray();
    ```

    Get first row object of query results:

    ```
      // Returns {"artistid":123,"artistname":"Alice"}  let firstRow = this.sql.exec("SELECT * FROM artist ORDER BY artistname DESC;").toArray()[0];
    ```

    Check if query results have exactly one row:

    ```
      // returns error  this.sql.exec("SELECT * FROM artist ORDER BY artistname ASC;").one();  // returns { artistid: 123, artistname: 'Alice' }  let oneRow = this.sql.exec("SELECT * FROM artist WHERE artistname = ?;", "Alice").one()
    ```

    Returned cursor behavior:

    ```
      let cursor = this.sql.exec("SELECT * FROM artist ORDER BY artistname ASC;");  let result = cursor.next();  if (!result.done) {    console.log(result.value); // prints { artistid: 123, artistname: 'Alice' }  } else {    // query returned zero results  }  let remainingRows = cursor.toArray();  console.log(remainingRows); // prints [{ artistid: 456, artistname: 'Bob' },{ artistid: 789, artistname: 'Charlie' }]
    ```

    Returned cursor and `raw()` iterator iterate over the same query results:

    ```
      let cursor = this.sql.exec("SELECT * FROM artist ORDER BY artistname ASC;");  let result = cursor.raw().next();  if (!result.done) {    console.log(result.value); // prints [ 123, 'Alice' ]  } else {    // query returned zero results  }  console.log(cursor.toArray()); // prints [{ artistid: 456, artistname: 'Bob' },{ artistid: 789, artistname: 'Charlie' }]
    ```

    `sql.exec().rowsRead()`:

    ```
      let cursor = this.sql.exec("SELECT * FROM artist;");  cursor.next()  console.log(cursor.rowsRead); // prints 1  cursor.toArray(); // consumes remaining cursor  console.log(cursor.rowsRead); // prints 3
    ```

    ## SQL in Durable Objects vs D1

    Cloudflare Workers offers a SQLite-backed serverless database product - [D1](/d1/). How should you compare [SQLite in Durable Objects](about:/durable-objects/best-practices/access-durable-objects-storage/#sql-storage) and D1?

    **D1 is a managed database product.**

    D1 fits into a familiar architecture for developers, where application servers communicate with a database over the network. Application servers are typically Workers; however, D1 also supports external, non-Worker access via an [HTTP API ↗](https://developers.cloudflare.com/api/operations/cloudflare-d1-query-database), which helps unlock [third-party tooling](about:/d1/reference/community-projects/#_top) support for D1.

    D1 aims for a "batteries included" feature set, including the above HTTP API, [database schema management](about:/d1/reference/migrations/#_top), [data import/export](/d1/build-with-d1/import-export-data/), and [database query insights](about:/d1/observability/metrics-analytics/#query-insights).

    With D1, your application code and SQL database queries are not colocated which can impact application performance. If performance is a concern with D1, Workers has [Smart Placement](about:/workers/configuration/smart-placement/#_top) to dynamically run your Worker in the best location to reduce total Worker request latency, considering everything your Worker talks to, including D1.

    **SQLite in Durable Objects is a lower-level compute with storage building block for distributed systems.**

    By design, Durable Objects are accessed with Workers-only.

    Durable Objects require a bit more effort, but in return, give you more flexibility and control. With Durable Objects, you must implement two pieces of code that run in different places: a front-end Worker which routes incoming requests from the Internet to a unique Durable Object, and the Durable Object itself, which runs on the same machine as the SQLite database. You get to choose what runs where, and it may be that your application benefits from running some application business logic right next to the database.

    With SQLite in Durable Objects, you may also need to build some of your own database tooling that comes out-of-the-box with D1.

    SQL query pricing and limits are intended to be identical between D1 ([pricing](/d1/platform/pricing/), [limits](/d1/platform/limits/)) and SQLite in Durable Objects ([pricing](about:/durable-objects/platform/pricing/#sql-storage-billing), [limits](/durable-objects/platform/limits/)). During SQLite in Durable Objects beta, Storage per Durable Object is 1GB, which will be raised to mirror storage per D1 database (10GB) by general availability.

    -   [Zero-latency SQLite storage in every Durable Object blog post ↗](https://blog.cloudflare.com/sqlite-in-durable-objects)

    ## Thank you for helping improve Cloudflare's documentation!
- title: Deploy your Video Call app · Cloudflare Durable Objects docs
  content: >-
    # Deploy your Video Call app · Cloudflare Durable Objects docs


    We're almost done with the project, and in this video, we'll add the
    finishing touches. Learn how to handle call disconnections, wire up
    essential media controls like muting/unmuting and video toggling, and
    integrate a TURN server to ensure reliable connections even behind
    firewalls. By the end of this video, your app will be fully functional and
    ready for deployment.


    ## Thank you for helping improve Cloudflare's documentation!
- title: Error handling · Cloudflare Durable Objects docs
  content: >-
    # Error handling · Cloudflare Durable Objects docs


    Any uncaught exceptions thrown by a Durable Object or thrown by Durable
    Objects' infrastructure (such as overloads or network errors) will be
    propagated to the callsite of the client. Catching these exceptions allows
    you to retry creating the [`DurableObjectStub`](/durable-objects/api/stub)
    and sending requests.


    JavaScript Errors with the property `.retryable` set to True are suggested
    to be retried if requests to the Durable Object are idempotent, or can be
    applied multiple times without changing the response. If requests are not
    idempotent, then you will need to decide what is best for your application.


    JavaScript Errors with the property `.overloaded` set to True should not be
    retried. If a Durable Object is overloaded, then retrying will worsen the
    overload and increase the overall error rate.


    It is strongly recommended to retry requests following the exponential
    backoff algorithm in production code when the error properties indicate that
    it is safe to do so.


    ## How exceptions are thrown


    Durable Objects can throw exceptions in one of two ways:


    -   An exception can be thrown within the user code which implements a
    Durable Object class. The resulting exception will have a `.remote` property
    set to `True` in this case.

    -   An exception can be generated by Durable Object's infrastructure. Some
    sources of infrastructure exceptions include: transient internal errors,
    sending too many requests to a single Durable Object, and too many requests
    being queued due to slow or excessive I/O (external API calls or storage
    operations) within an individual Durable Object. Some infrastructure
    exceptions may also have the `.remote` property set to `True` -- for
    example, when the Durable Object exceeds its memory or CPU limits.


    Refer to [Troubleshooting](/durable-objects/observability/troubleshooting/)
    to review the types of errors returned by a Durable Object and/or Durable
    Objects infrastructure and how to prevent them.


    ## Example


    This example demonstrates retrying requests using the recommended
    exponential backoff algorithm.


    ```

    import { DurableObject } from "cloudflare:workers";export interface Env
    {  ErrorThrowingObject: DurableObjectNamespace;}export default {  async
    fetch(request, env, ctx) {    let userId = new
    URL(request.url).searchParams.get("userId") || "";    const id =
    env.ErrorThrowingObject.idFromName(userId);    // Retry behavior can be
    adjusted to fit your application.    let maxAttempts = 3;    let
    baseBackoffMs = 100;    let maxBackoffMs = 20000;    let attempt =
    0;    while (true) {      // Try sending the request      try {        //
    Create a Durable Object stub for each attempt, because certain types
    of        // errors will break the Durable Object stub.        const doStub
    = env.ErrorThrowingObject.get(id);        const resp = await
    doStub.fetch("http://your-do/");        return Response.json(resp);      }
    catch (e: any) {        if (!e.retryable) {          // Failure was not a
    transient internal error, so don't
    retry.          break;        }      }      let backoffMs =
    Math.min(        maxBackoffMs,        baseBackoffMs * Math.random() *
    Math.pow(2, attempt),      );      attempt += 1;      if (attempt >=
    maxAttempts) {        // Reached max attempts, so don't
    retry.        break;      }      await
    scheduler.wait(backoffMs);    }    return new Response("server error", {
    status: 500 });  },} satisfies ExportedHandler<Env>;export class
    ErrorThrowingObject extends DurableObject {  constructor(state:
    DurableObjectState, env: Env) {    super(state, env);    // Any exceptions
    that are raised in your constructor will also set the    // .remote property
    to True    throw new Error("no good");  }  async fetch(req: Request) {    //
    Generate an uncaught exception    // A .remote property will be added to the
    exception propagated to the caller    // and will be set to True    throw
    new Error("example error");    // We never reach this    return
    Response.json({});  }}

    ```


    ## Thank you for helping improve Cloudflare's documentation!
- title: Using WebSockets · Cloudflare Durable Objects docs
  content: |-
    # Using WebSockets · Cloudflare Durable Objects docs

    WebSockets are long-lived TCP connections that enable bi-directional, real-time communication between client and server. Both Cloudflare Durable Objects and Workers can act as WebSocket endpoints – either as a client or as a server. Because WebSocket sessions are long-lived, applications commonly use Durable Objects to accept either the client or server connection. While there are other use cases for using Workers exclusively with WebSockets, for example proxying WebSocket messages, WebSockets are most useful when combined with Durable Objects.

    Because Durable Objects provide a single-point-of-coordination between [Cloudflare Workers](/workers/), a single Durable Object instance can be used in parallel with WebSockets to coordinate between multiple clients, such as participants in a chat room or a multiplayer game. Refer to [Cloudflare Edge Chat Demo ↗](https://github.com/cloudflare/workers-chat-demo) for an example of using Durable Objects with WebSockets.

    Both Cloudflare Durable Objects and Workers can use the [Web Standard WebSocket API](/workers/runtime-apis/websockets/) to build applications, but a major differentiator of Cloudflare Durable Objects relative to other platforms is the ability to Hibernate WebSocket connections to save costs.

    This guide covers:

    1.  Building a WebSocket server using Web Standard APIs
    2.  Using WebSocket Hibernation APIs.

    ## WebSocket Standard API

    WebSocket connections are established by making an HTTP GET request with the `Upgrade: websocket` header. A Cloudflare Worker is commonly used to validate the request, proxy the request to the Durable Object to accept the server side connection, and return the client side connection in the response.

    -   [JavaScript](#tab-panel-1399)
    -   [TypeScript](#tab-panel-1400)

    ```
    // Workerexport default {  async fetch(request, env, ctx) {    if (request.method === "GET" && request.url.endsWith("/websocket")) {      // Expect to receive a WebSocket Upgrade request.      // If there is one, accept the request and return a WebSocket Response.      const upgradeHeader = request.headers.get("Upgrade");      if (!upgradeHeader || upgradeHeader !== "websocket") {        return new Response(null, {          status: 426,          statusText: "Durable Object expected Upgrade: websocket",          headers: {            "Content-Type": "text/plain",          },        });      }      // This example will refer to a single Durable Object instance, since the name "foo" is      // hardcoded      let id = env.WEBSOCKET_SERVER.idFromName("foo");      let stub = env.WEBSOCKET_SERVER.get(id);      // The Durable Object's fetch handler will accept the server side connection and return      // the client      return stub.fetch(request);    }    return new Response(null, {      status: 400,      statusText: "Bad Request",      headers: {        "Content-Type": "text/plain",      },    });  },};
    ```

    Each WebSocket server in this example is represented by a Durable Object. This WebSocket server creates a single WebSocket connection and responds to all messages over that connection with the total number of accepted WebSocket connections. In the Durable Object's fetch handler we create client and server connections and add event listeners for relevant event types.

    -   [JavaScript](#tab-panel-1401)
    -   [TypeScript](#tab-panel-1402)

    ```
    import { DurableObject } from "cloudflare:workers";// Durable Objectexport class WebSocketServer extends DurableObject {  currentlyConnectedWebSockets;  constructor(ctx, env) {    // This is reset whenever the constructor runs because    // regular WebSockets do not survive Durable Object resets.    //    // WebSockets accepted via the Hibernation API can survive    // a certain type of eviction, but we will not cover that here.    super(ctx, env);    this.currentlyConnectedWebSockets = 0;  }  async fetch(request) {    // Creates two ends of a WebSocket connection.    const webSocketPair = new WebSocketPair();    const [client, server] = Object.values(webSocketPair);    // Calling `accept()` tells the runtime that this WebSocket is to begin terminating    // request within the Durable Object. It has the effect of "accepting" the connection,    // and allowing the WebSocket to send and receive messages.    server.accept();    this.currentlyConnectedWebSockets += 1;    // Upon receiving a message from the client, the server replies with the same message,    // and the total number of connections with the "[Durable Object]: " prefix    server.addEventListener("message", (event) => {      server.send(        `[Durable Object] currentlyConnectedWebSockets: ${this.currentlyConnectedWebSockets}`,      );    });    // If the client closes the connection, the runtime will close the connection too.    server.addEventListener("close", (cls) => {      this.currentlyConnectedWebSockets -= 1;      server.close(cls.code, "Durable Object is closing WebSocket");    });    return new Response(null, {      status: 101,      webSocket: client,    });  }}
    ```

    To execute this code, configure your `wrangler.toml` file to include a Durable Object [binding](about:/durable-objects/get-started/#5-configure-durable-object-bindings) and [migration](/durable-objects/reference/durable-objects-migrations/) based on the namespace and class name chosen previously.

    ```
    name = "websocket-server"[[durable_objects.bindings]]name = "WEBSOCKET_SERVER"class_name = "WebSocketServer"[[migrations]]tag = "v1"new_classes = ["WebSocketServer"]
    ```

    A full example can be found in [Build a WebSocket server](/durable-objects/examples/websocket-server/).

    ## WebSocket Hibernation API

    In addition to [Workers WebSocket API](/workers/runtime-apis/websockets/), Cloudflare Durable Objects can use the WebSocket Hibernation API which extends the Web Standard WebSocket API to reduce costs. Specifically, [billable Duration (GB-s) charges](/durable-objects/platform/pricing/) are not incurred during periods of inactivity. Note that other events, for example [alarms](/durable-objects/api/alarms/), can prevent a Durable Object from being inactive and therefore prevent this cost saving.

    The WebSocket consists of Cloudflare-specific extensions to the Web Standard WebSocket API. These extensions are either present on the [DurableObjectState](/durable-objects/api/state) interface, or as handler methods on the Durable Object class.

    The Worker used in the WebSocket Standard API example does not require any code changes to make use of the WebSocket Hibernation API. The changes to the Durable Object are described in the code sample below. In summary, [`DurableObjectState::acceptWebSocket`](about:/durable-objects/api/state/#acceptwebsocket) is called to accept the server side of the WebSocket connection, and handler methods are defined on the Durable Object class for relevant event types rather than adding event listeners.

    If an event occurs for a hibernated Durable Object's corresponding handler method, it will return to memory. This will call the Durable Object's constructor, so it is best to minimize work in the constructor when using WebSocket hibernation.

    -   [JavaScript](#tab-panel-1403)
    -   [TypeScript](#tab-panel-1404)

    ```
    import { DurableObject } from "cloudflare:workers";// Durable Objectexport class WebSocketHibernationServer extends DurableObject {  async fetch(request) {    // Creates two ends of a WebSocket connection.    const webSocketPair = new WebSocketPair();    const [client, server] = Object.values(webSocketPair);    // Calling `acceptWebSocket()` informs the runtime that this WebSocket is to begin terminating    // request within the Durable Object. It has the effect of "accepting" the connection,    // and allowing the WebSocket to send and receive messages.    // Unlike `ws.accept()`, `state.acceptWebSocket(ws)` informs the Workers Runtime that the WebSocket    // is "hibernatable", so the runtime does not need to pin this Durable Object to memory while    // the connection is open. During periods of inactivity, the Durable Object can be evicted    // from memory, but the WebSocket connection will remain open. If at some later point the    // WebSocket receives a message, the runtime will recreate the Durable Object    // (run the `constructor`) and deliver the message to the appropriate handler.    this.ctx.acceptWebSocket(server);    return new Response(null, {      status: 101,      webSocket: client,    });  }  async webSocketMessage(ws, message) {    // Upon receiving a message from the client, reply with the same message,    // but will prefix the message with "[Durable Object]: " and return the    // total number of connections.    ws.send(      `[Durable Object] message: ${message}, connections: ${this.ctx.getWebSockets().length}`,    );  }  async webSocketClose(ws, code, reason, wasClean) {    // If the client closes the connection, the runtime will invoke the webSocketClose() handler.    ws.close(code, "Durable Object is closing WebSocket");  }}
    ```

    Similar to the WebSocket Standard API example, to execute this code, configure your `wrangler.toml` file to include a Durable Object [binding](about:/durable-objects/get-started/#5-configure-durable-object-bindings) and [migration](/durable-objects/reference/durable-objects-migrations/) based on the namespace and class name chosen previously.

    ```
    name = "websocket-hibernation-server"[[durable_objects.bindings]]name = "WEBSOCKET_HIBERNATION_SERVER"class_name = "WebSocketHibernationServer"[[migrations]]tag = "v1"new_classes = ["WebSocketHibernationServer"]
    ```

    A full example can be found in [Build a WebSocket server with WebSocket Hibernation](/durable-objects/examples/websocket-hibernation-server/).

    -   [Mozilla Developer Network's (MDN) documentation on the WebSocket class ↗](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)
    -   [Cloudflare's WebSocket template for building applications on Workers using WebSockets ↗](https://github.com/cloudflare/websocket-template)

    ## Thank you for helping improve Cloudflare's documentation!
- title: Durable Object Namespace · Cloudflare Durable Objects docs
  content: |-
    # Durable Object Namespace · Cloudflare Durable Objects docs

    ## Description

    A Durable Object namespace is a set of Durable Objects that are backed by the same Durable Object class. There is only one Durable Object namespace per class. A Durable Object namespace can contain any number of Durable Objects.

    The `DurableObjectNamespace` interface is used to obtain a reference to new or existing Durable Objects. The interface is accessible from the fetch handler on a Cloudflare Worker via the `env` parameter, which is the standard interface when referencing bindings declared in `wrangler.toml`.

    This interface defines several [methods](about:/durable-objects/api/namespace/#methods) that can be used to create an ID for a Durable Object. Note that creating an ID for a Durable Object does not create the Durable Object. The Durable Object is created lazily after calling [`DurableObjectNamespace::get`](about:/durable-objects/api/namespace/#get) to create a [`DurableObjectStub`](/durable-objects/api/stub) from a `DurableObjectId`. This ensures that objects are not constructed until they are actually accessed.

    -   [JavaScript](#tab-panel-1357)
    -   [TypeScript](#tab-panel-1358)

    ```
    import { DurableObject } from "cloudflare:workers";// Durable Objectexport class MyDurableObject extends DurableObject {  ...}// Workerexport default {  async fetch(request, env) {    // Every unique ID refers to an individual instance of the Durable Object class    const id = env.MY_DURABLE_OBJECT.idFromName("foo");    // A stub is a client Object used to invoke methods defined by the Durable Object    const stub = env.MY_DURABLE_OBJECT.get(id);    ...  }}
    ```

    ## Methods

    ### `idFromName`

    `idFromName` creates a unique [`DurableObjectId`](/durable-objects/api/id) which refers to an individual instance of the Durable Object class. Named Durable Objects are the most common method of referring to Durable Objects.

    ```
    const fooId = env.MY_DURABLE_OBJECT.idFromName("foo");const barId = env.MY_DURABLE_OBJECT.idFromName("bar");
    ```

    #### Parameters

    -   A required string to be used to generate a [`DurableObjectId`](/durable-objects/api/id) corresponding to the name of a Durable Object.

    #### Return values

    -   A [`DurableObjectId`](/durable-objects/api/id) referring to an instance of a Durable Object class.

    ### `newUniqueId`

    `newUniqueId` creates a randomly generated and unique [`DurableObjectId`](/durable-objects/api/id) which refers to an individual instance of the Durable Object class. IDs created using `newUniqueId`, will need to be stored as a string in order to refer to the same Durable Object again in the future. For example, the ID can be stored in Workers KV, another Durable Object, or in a cookie in the user's browser.

    ```
    const id = env.MY_DURABLE_OBJECT.newUniqueId();const euId = env.MY_DURABLE_OBJECT.newUniqueId({ jurisdiction: "eu" });
    ```

    #### Parameters

    -   An optional object with the key `jurisdiction` and value of a [jurisdiction](about:/durable-objects/reference/data-location/#restrict-durable-objects-to-a-jurisdiction) string.

    #### Return values

    -   A [`DurableObjectId`](/durable-objects/api/id) referring to an instance of the Durable Object class.

    ### `idFromString`

    `idFromString` creates a [`DurableObjectId`](/durable-objects/api/id) from a previously generated ID that has been converted to a string. This method throws an exception if the ID is invalid, for example, if the ID was not created from the same `DurableObjectNamespace`.

    ```
    // Create a new unique IDconst id = env.MY_DURABLE_OBJECT.newUniqueId();// Convert the ID to a string to be saved elsewhere, e.g. a session cookieconst session_id = id.toString();...// Recreate the ID from the stringconst id = env.MY_DURABLE_OBJECT.idFromString(session_id);
    ```

    #### Parameters

    -   A required string corresponding to a [`DurableObjectId`](/durable-objects/api/id) previously generated either by `newUniqueId` or `idFromName`.

    #### Return values

    -   A [`DurableObjectId`](/durable-objects/api/id) referring to an instance of a Durable Object class.

    ### `get`

    `get` obtains a [`DurableObjectStub`](/durable-objects/api/stub) from a [`DurableObjectId`](/durable-objects/api/id) which can be used to invoke methods on a Durable Object.

    This method returns the stub immediately, often before a connection has been established to the Durable Object. This allows requests to be sent to the instance right away, without waiting for a network round trip.

    ```
    const id = env.MY_DURABLE_OBJECT.newUniqueId();const stub = env.MY_DURABLE_OBJECT.get(id);
    ```

    #### Parameters

    -   A required [`DurableObjectId`](/durable-objects/api/id)
    -   An optional object with the key `locationHint` and value of a [locationHint](about:/durable-objects/reference/data-location/#provide-a-location-hint) string.

    #### Return values

    -   A [`DurableObjectStub`](/durable-objects/api/stub) referring to an instance of a Durable Object class.

    ### `jurisdiction`

    `jurisdiction` creates a subnamespace from a namespace where all Durable Object IDs and references created from that subnamespace will be restricted to the specified [jurisdiction](about:/durable-objects/reference/data-location/#restrict-durable-objects-to-a-jurisdiction).

    ```
    const subnamespace = env.MY_DURABLE_OBJECT.jurisdiction("foo");const euId = subnamespace.idFromName("foo");
    ```

    #### Parameters

    -   A required [jurisdiction](about:/durable-objects/reference/data-location/#restrict-durable-objects-to-a-jurisdiction) string.

    #### Return values

    -   A `DurableObjectNamespace` scoped to a particular geographic jurisdiction.

    -   [Durable Objects: Easy, Fast, Correct – Choose Three ↗](https://blog.cloudflare.com/durable-objects-easy-fast-correct-choose-three/).

    ## Thank you for helping improve Cloudflare's documentation!
- title: Durable Object ID · Cloudflare Durable Objects docs
  content: |-
    # Durable Object ID · Cloudflare Durable Objects docs

    ## Description

    A Durable Object ID is a 64-digit hexadecimal number used to identify a Durable Object. Not all 64-digit hex numbers are valid IDs. Durable Object IDs are constructed indirectly via the [`DurableObjectNamespace`](/durable-objects/api/namespace) interface.

    The `DurableObjectId` interface refers to a new or existing Durable Object. This interface is most frequently used by [`DurableObjectNamespace::get`](about:/durable-objects/api/namespace/#get) to obtain a [`DurableObjectStub`](/durable-objects/api/stub) for submitting requests to a Durable Object. Note that creating an ID for a Durable Object does not create the Durable Object. The Durable Object is created lazily after creating a stub from a `DurableObjectId`. This ensures that objects are not constructed until they are actually accessed.

    ## Methods

    ### `toString`

    `toString` converts a `DurableObjectId` to a 64 digit hex string. This string is useful for logging purposes or storing the `DurableObjectId` elsewhere, for example, in a session cookie. This string can be used to reconstruct a `DurableObjectId` via `DurableObjectNamespace::idFromString`.

    ```
    // Create a new unique IDconst id = env.MY_DURABLE_OBJECT.newUniqueId();// Convert the ID to a string to be saved elsewhere, e.g. a session cookieconst session_id = id.toString();...// Recreate the ID from the stringconst id = env.MY_DURABLE_OBJECT.idFromString(session_id);
    ```

    #### Parameters

    -   None.

    #### Return values

    -   A 64 digit hex string.

    ### `equals`

    `equals` is used to compare equality between two instances of `DurableObjectId`.

    ```
    const id1 = env.MY_DURABLE_OBJECT.newUniqueId();const id2 = env.MY_DURABLE_OBJECT.newUniqueId();console.assert(!id1.equals(id2), "Different unique ids should never be equal.");
    ```

    #### Parameters

    -   A required `DurableObjectId` to compare against.

    #### Return values

    -   A boolean. True if equal and false otherwise.

    ## Properties

    ### `name`

    `name` is an optional property of a `DurableObjectId`, which returns the name that was used to create the `DurableObjectId` via [`DurableObjectNamespace::idFromName`](about:/durable-objects/api/namespace/#idfromname). This value is undefined if the `DurableObjectId` was constructed using [`DurableObjectNamespace::newUniqueId`](about:/durable-objects/api/namespace/#newuniqueid).

    ```
    const uniqueId = env.MY_DURABLE_OBJECT.newUniqueId();const fromNameId = env.MY_DURABLE_OBJECT.idFromName("foo");console.assert(uniqueId.name === undefined, "unique ids have no name");console.assert(  fromNameId.name === "foo",  "name matches parameter to idFromName",);
    ```

    -   [Durable Objects: Easy, Fast, Correct – Choose Three ↗](https://blog.cloudflare.com/durable-objects-easy-fast-correct-choose-three/).

    ## Thank you for helping improve Cloudflare's documentation!
- title: Durable Object Stub · Cloudflare Durable Objects docs
  content: |-
    # Durable Object Stub · Cloudflare Durable Objects docs

    ## Description

    The `DurableObjectStub` interface is a client used to invoke methods on a remote Durable Object. The type of `DurableObjectStub` is generic to allow for RPC methods to be invoked on the stub.

    Durable Objects implement E-order semantics, a concept deriving from the [E distributed programming language ↗](https://en.wikipedia.org/wiki/E_\(programming_language\)). When you make multiple calls to the same Durable Object, it is guaranteed that the calls will be delivered to the remote Durable Object in the order in which you made them. E-order semantics makes many distributed programming problems easier. E-order is implemented by the [Cap'n Proto ↗](https://capnproto.org/) distributed object-capability RPC protocol, which Cloudflare Workers uses for internal communications.

    If an exception is thrown by a Durable Object stub all in-flight calls and future calls will fail with [exceptions](/durable-objects/observability/troubleshooting/). To continue invoking methods on a remote Durable Object a Worker must recreate the stub. There are no ordering guarantees between different stubs.

    -   [JavaScript](#tab-panel-1369)
    -   [TypeScript](#tab-panel-1370)

    ```
    import { DurableObject } from "cloudflare:workers";// Durable Objectexport class MyDurableObject extends DurableObject {  constructor(ctx, env) {    super(ctx, env);  }  async sayHello() {    return "Hello, World!";  }}// Workerexport default {  async fetch(request, env) {    // Every unique ID refers to an individual instance of the Durable Object class    const id = env.MY_DURABLE_OBJECT.idFromName("foo");    // A stub is a client used to invoke methods on the Durable Object    const stub = env.MY_DURABLE_OBJECT.get(id);    // Methods on the Durable Object are invoked via the stub    const rpcResponse = await stub.sayHello();    return new Response(rpcResponse);  },};
    ```

    ## Properties

    ### `id`

    `id` is a property of the `DurableObjectStub` corresponding to the [`DurableObjectId`](/durable-objects/api/id) used to create the stub.

    ```
    const id = env.MY_DURABLE_OBJECT.newUniqueId();const stub = env.MY_DURABLE_OBJECT.get(id);console.assert(id.equals(stub.id), "This should always be true");
    ```

    ### `name`

    `name` is an optional property of a `DurableObjectStub`, which returns the name that was used to create the [`DurableObjectId`](/durable-objects/api/id) via [`DurableObjectNamespace::idFromName`](about:/durable-objects/api/namespace/#idfromname) which was then used to create the `DurableObjectStub`. This value is undefined if the [`DurableObjectId`](/durable-objects/api/id) used to create the `DurableObjectStub` was constructed using [`DurableObjectNamespace::newUniqueId`](about:/durable-objects/api/namespace/#newuniqueid).

    ```
    const id = env.MY_DURABLE_OBJECT.idFromName("foo");const stub = env.MY_DURABLE_OBJECT.get(id);console.assert(stub.name === "foo", "This should always be true");
    ```

    -   [Durable Objects: Easy, Fast, Correct – Choose Three ↗](https://blog.cloudflare.com/durable-objects-easy-fast-correct-choose-three/).

    ## Thank you for helping improve Cloudflare's documentation!
- title: Durable Object State · Cloudflare Durable Objects docs
  content: |-
    # Durable Object State · Cloudflare Durable Objects docs

    ## Description

    The `DurableObjectState` interface is accessible as an instance property on the Durable Object class. This interface encapsulates methods that modify the state of a Durable Object, for example which WebSockets are attached to a Durable Object or how the runtime should handle concurrent Durable Object requests.

    The `DurableObjectState` interface is different from the Storage API in that it does not have top-level methods which manipulate persistent application data. These methods are instead encapsulated in the [`DurableObjectStorage`](/durable-objects/api/storage-api) interface and accessed by [`DurableObjectState::storage`](about:/durable-objects/api/state/#storage).

    -   [JavaScript](#tab-panel-1363)
    -   [TypeScript](#tab-panel-1364)

    ```
    import { DurableObject } from "cloudflare:workers";// Durable Objectexport class MyDurableObject extends DurableObject {  // DurableObjectState is accessible via the ctx instance property  constructor(ctx, env) {    super(ctx, env);  }  ...}
    ```

    ## Methods

    ### `waitUntil`

    `waitUntil` waits until the promise which is passed as a parameter resolves and can extends an event context up to 30 seconds after the last client disconnects.

    #### Parameters

    -   A required promise of any type.

    #### Return values

    -   None.

    ### `blockConcurrencyWhile`

    `blockConcurrencyWhile` executes an async callback while blocking any other events from being delivered to the Durable Object until the callback completes. This method guarantees ordering and prevents concurrent requests. All events that were not explicitly initiated as part of the callback itself will be blocked. Once the callback completes, all other events will be delivered.

    `blockConcurrencyWhile` is commonly used within the constructor of the Durable Object class to enforce initialization to occur before any requests are delivered. Another use case is executing `async` operations based on the current state of the Durable Object and using `blockConcurrencyWhile` to prevent that state from changing while yielding the event loop.

    If the callback throws an exception, the object will be terminated and reset. This ensures that the object cannot be left stuck in an uninitialized state if something fails unexpectedly. To avoid this behavior, enclose the body of your callback in a `try...catch` block to ensure it cannot throw an exception.

    To help mitigate deadlocks there is a 30 second timeout applied when executing the callback. If this timeout is exceeded, the Durable Object will be reset. It is best practice to have the callback do as little work as possible to improve overall request throughput to the Durable Object.

    ```
    // Durable Objectexport class MyDurableObject extends DurableObject {  initialized = false;  constructor(ctx, env) {    super(ctx, env);    // blockConcurrencyWhile will ensure that initialized will always be true    this.ctx.blockConcurrencyWhile(async () => {      this.initialized = true;    });  }  ...}
    ```

    #### Parameters

    -   A required callback which returns a `Promise<T>`.

    #### Return values

    -   A `Promise<T>` returned by the callback.

    ### `acceptWebSocket`

    `acceptWebSocket` is part of the [WebSocket Hibernation API](about:/durable-objects/best-practices/websockets/#websocket-hibernation-api), which allows a Durable Object to be removed from memory to save costs while keeping its WebSockets connected.

    `acceptWebSocket` adds a WebSocket to the set of WebSockets attached to the Durable Object. Once called, any incoming messages will be delivered by calling the Durable Object's `webSocketMessage` handler, and `webSocketClose` will be invoked upon disconnect. After calling `acceptWebSocket`, the WebSocket is accepted and its `send` and `close` methods can be used.

    The [WebSocket Hibernation API](about:/durable-objects/best-practices/websockets/#websocket-hibernation-api) takes the place of the standard [WebSockets API](/workers/runtime-apis/websockets/). Therefore, `ws.accept` must not have been called separately and `ws.addEventListener` method will not receive events as they will instead be delivered to the Durable Object.

    The WebSocket Hibernation API permits a maximum of 32,768 WebSocket connections per Durable Object, but the CPU and memory usage of a given workload may further limit the practical number of simultaneous connections.

    #### Parameters

    -   A required `WebSocket` with name `ws`.
    -   An optional `Array<string>` of associated tags. Tags can be used to retrieve WebSockets via [`DurableObjectState::getWebSockets`](about:/durable-objects/api/state/#getwebsockets). Each tag is a maximum of 256 characters and there can be at most 10 tags associated with a WebSocket.

    #### Return values

    -   None.

    ### `getWebSockets`

    `getWebSockets` is part of the [WebSocket Hibernation API](about:/durable-objects/best-practices/websockets/#websocket-hibernation-api), which allows a Durable Object to be removed from memory to save costs while keeping its WebSockets connected.

    `getWebSockets` returns an `Array<WebSocket>` which is the set of WebSockets attached to the Durable Object. An optional tag argument can be used to filter the list according to tags supplied when calling [`DurableObjectState::acceptWebSocket`](about:/durable-objects/api/state/#acceptwebsocket).

    #### Parameters

    -   An optional tag of type `string`.

    #### Return values

    -   An `Array<WebSocket>`.

    ### `setWebSocketAutoResponse`

    `setWebSocketAutoResponse` is part of the [WebSocket Hibernation API](about:/durable-objects/best-practices/websockets/#websocket-hibernation-api), which allows a Durable Object to be removed from memory to save costs while keeping its WebSockets connected.

    `setWebSocketAutoResponse` sets an automatic response, auto-response, for the request provided for all WebSockets attached to the Durable Object. If a request is received matching the provided request then the auto-response will be returned without waking WebSockets in hibernation and incurring billable duration charges.

    `setWebSocketAutoResponse` is a common alternative to setting up a server for static ping/pong messages because this can be handled without waking hibernating WebSockets.

    #### Parameters

    -   An optional `WebSocketRequestResponsePair(request string, response string)` enabling any WebSocket accepted via [`DurableObjectState::acceptWebSocket`](about:/durable-objects/api/state/#acceptwebsocket) to automatically reply to the provided response when it receives the provided request. Both request and response are limited to 2,048 characters each. If the parameter is omitted, any previously set auto-response configuration will be removed. [`DurableObjectState::getWebSocketAutoResponseTimestamp`](about:/durable-objects/api/state/#getwebsocketautoresponsetimestamp) will still reflect the last timestamp that an auto-response was sent.

    #### Return values

    -   None.

    ### `getWebSocketAutoResponse`

    `getWebSocketAutoResponse` returns the `WebSocketRequestResponsePair` object last set by [`DurableObjectState::setWebSocketAutoResponse`](about:/durable-objects/api/state/#setwebsocketautoresponse), or null if not auto-response has been set.

    #### Parameters

    -   None.

    #### Return values

    -   A `WebSocketRequestResponsePair` or null.

    ### `getWebSocketAutoResponseTimestamp`

    `getWebSocketAutoResponseTimestamp` is part of the [WebSocket Hibernation API](about:/durable-objects/best-practices/websockets/#websocket-hibernation-api), which allows a Durable Object to be removed from memory to save costs while keeping its WebSockets connected.

    `getWebSocketAutoResponseTimestamp` gets the most recent `Date` on which the given WebSocket sent an auto-response, or null if the given WebSocket never sent an auto-response.

    #### Parameters

    -   A required `WebSocket`.

    #### Return values

    -   A `Date` or null.

    ### `setHibernatableWebSocketEventTimeout`

    `setHibernatableWebSocketEventTimeout` is part of the [WebSocket Hibernation API](about:/durable-objects/best-practices/websockets/#websocket-hibernation-api), which allows a Durable Object to be removed from memory to save costs while keeping its WebSockets connected.

    `setHibernatableWebSocketEventTimeout` sets the maximum amount of time in milliseconds that a WebSocket event can run for.

    If no parameter or a parameter of `0` is provided and a timeout has been previously set, then the timeout will be unset. The maximum value of timeout is 604,800,000 ms (7 days).

    #### Parameters

    -   An optional `number`.

    #### Return values

    -   None.

    ### `getHibernatableWebSocketEventTimeout`

    `getHibernatableWebSocketEventTimeout` is part of the [WebSocket Hibernation API](about:/durable-objects/best-practices/websockets/#websocket-hibernation-api), which allows a Durable Object to be removed from memory to save costs while keeping its WebSockets connected.

    `getHibernatableWebSocketEventTimeout` gets the currently set hibernatable WebSocket event timeout if one has been set via [`DurableObjectState::setHibernatableWebSocketEventTimeout`](about:/durable-objects/api/state/#sethibernatablewebsocketeventtimeout).

    #### Parameters

    -   None.

    #### Return values

    -   A number, or null if the timeout has not been set.

    ### `getTags`

    `getTags` is part of the [WebSocket Hibernation API](about:/durable-objects/best-practices/websockets/#websocket-hibernation-api), which allows a Durable Object to be removed from memory to save costs while keeping its WebSockets connected.

    `getTags` returns tags associated with a given WebSocket. This method throws an exception if the WebSocket has not been associated with the Durable Object via [`DurableObjectState::acceptWebSocket`](about:/durable-objects/api/state/#acceptwebsocket).

    #### Parameters

    -   A required `WebSocket`.

    #### Return values

    -   An `Array<string>` of tags.

    ### `abort`

    `abort` is used to forcibly reset a Durable Object. A JavaScript `Error` with the message passed as a parameter will be logged. This error is not able to be caught within the application code.

    ```
    // Durable Objectexport class MyDurableObject extends DurableObject {  constructor(ctx: DurableObjectState, env: Env) {    super(ctx, env);  }  async sayHello() {    // Error: Hello, World! will be logged    this.ctx.abort("Hello, World!");  }}
    ```

    #### Parameters

    -   An optional `string` .

    #### Return values

    -   None.

    ## Properties

    ### `id`

    `id` is a readonly property of type `DurableObjectId` corresponding to the [`DurableObjectId`](/durable-objects/api/id) of the Durable Object.

    ### `storage`

    `storage` is a readonly property of type `DurableObjectStorage` encapsulating the [Storage API](/durable-objects/api/storage-api).

    -   [Durable Objects: Easy, Fast, Correct – Choose Three ↗](https://blog.cloudflare.com/durable-objects-easy-fast-correct-choose-three/).

    ## Thank you for helping improve Cloudflare's documentation!
- title: Durable Object Storage · Cloudflare Durable Objects docs
  content: |-
    # Durable Object Storage · Cloudflare Durable Objects docs

    The Durable Object Storage API allows Durable Objects to access transactional and strongly consistent storage. A Durable Object's attached storage is private to its unique instance and cannot be accessed by other objects.

    Durable Objects gain access to a persistent Durable Object Storage API via `ctx.storage`, on the `ctx` parameter passed to the Durable Object constructor.

    While access to a Durable Object is single-threaded, request executions can still interleave with each other when they wait on I/O, such as when waiting on the promises returned by persistent storage methods or `fetch()` requests.

    The following code snippet shows you how to store and retrieve data using the Durable Object Storage API.

    ```
    export class Counter {  constructor(ctx, env) {    this.ctx = ctx;  }  async fetch(request) {    let url = new URL(request.url);    // retrieve data    let value = (await this.ctx.storage.get("value")) || 0;    // increment counter and get a new value    value += 1;    // store data    await this.ctx.storage.put("value", value);    return new Response(value);  }}
    ```

    ## Methods

    The Durable Object Storage API comes with several methods, including key-value (KV) API, SQL API, and point-in-time-recovery (PITR) API.

    -   Durable Object classes with the default, key-value storage backend can use KV API.
    -   Durable Object classes with the [SQLite storage backend](about:/durable-objects/best-practices/access-durable-objects-storage/#sqlite-storage-backend) can use KV API, SQL API, and PITR API. KV API methods like `get()`, `put()`, `delete()`, or `list()` store data in a hidden SQLite table.

    Each method is implicitly wrapped inside a transaction, such that its results are atomic and isolated from all other storage operations, even when accessing multiple key-value pairs.

    ### `get`

    -   `get(key string , options Object optional)`: Promise<any>
        
        -   Retrieves the value associated with the given key. The type of the returned value will be whatever was previously written for the key, or undefined if the key does not exist.
    -   `get(keys Array<string> , options Object optional)`: Promise<Map<string, any>>
        
        -   Retrieves the values associated with each of the provided keys. The type of each returned value in the [`Map` ↗](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) will be whatever was previously written for the corresponding key. Results in the `Map` will be sorted in increasing order of their UTF-8 encodings, with any requested keys that do not exist being omitted. Supports up to 128 keys at a time.

    #### Supported options

    -   `allowConcurrency`: boolean
        
        -   By default, the system will pause delivery of I/O events to the Object while a storage operation is in progress, in order to avoid unexpected race conditions. Pass `allowConcurrency: true` to opt out of this behavior and allow concurrent events to be delivered.
    -   `noCache`: boolean
        
        -   If true, then the key/value will not be inserted into the in-memory cache. If the key is already in the cache, the cached value will be returned, but its last-used time will not be updated. Use this when you expect this key will not be used again in the near future. This flag is only a hint. This flag will never change the semantics of your code, but it may affect performance.

    ### `put`

    -   `put(key string , value any , options Object optional)`: Promise
        
        -   Stores the value and associates it with the given key. The value can be any type supported by the [structured clone algorithm ↗](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm), which is true of most types. Keys are limited to a max size of 2,048 bytes and values are limited to 128 KiB (131,072 bytes).
    -   `put(entries Object , options Object optional)`: Promise
        
        -   Takes an Object and stores each of its keys and values to storage.
        -   Each value can be any type supported by the [structured clone algorithm ↗](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm), which is true of most types.
        -   Supports up to 128 key-value pairs at a time. Each key is limited to a maximum size of 2,048 bytes and each value is limited to 128 KiB (131,072 bytes).

    ### `delete`

    -   `delete(key string , options Object optional)`: Promise<boolean>
        
        -   Deletes the key and associated value. Returns `true` if the key existed or `false` if it did not.
    -   `delete(keys Array<string> , options Object optional)`: Promise<number>
        
        -   Deletes the provided keys and their associated values. Supports up to 128 keys at a time. Returns a count of the number of key-value pairs deleted.

    ### `deleteAll`

    -   `deleteAll(options Object optional)`: Promise
        
        -   Deletes all stored data, effectively deallocating all storage used by the Durable Object. For Durable Objects with a key-value storage backend, `deleteAll()` removes all keys and associated values for an individual Durable Object. For Durable Objects with a [SQLite storage backend](about:/durable-objects/best-practices/access-durable-objects-storage/#sqlite-storage-backend), `deleteAll()` removes the entire contents of a Durable Object's private SQLite database, including both SQL data and key-value data.
        -   For Durable Objects with a key-value storage backend, an in-progress `deleteAll()` operation can fail, which may leave a subset of data undeleted. Durable Objects with a SQLite storage backend do not have a partial `deleteAll()` issue because `deleteAll()` operations are atomic (all or nothing).
        -   `deleteAll()` does not proactively delete [Alarms](/durable-objects/api/alarms/). Use [`deleteAlarm()`](about:/durable-objects/api/alarms/#deletealarm) to delete an alarm.

    #### Supported options

    -   `put()`, `delete()` and `deleteAll()` support the following options:
        
    -   `allowUnconfirmed` boolean
        
        -   By default, the system will pause outgoing network messages from the Durable Object until all previous writes have been confirmed flushed to disk. If the write fails, the system will reset the Object, discard all outgoing messages, and respond to any clients with errors instead.
            
        -   This way, Durable Objects can continue executing in parallel with a write operation, without having to worry about prematurely confirming writes, because it is impossible for any external party to observe the Object's actions unless the write actually succeeds.
            
        -   After any write, subsequent network messages may be slightly delayed. Some applications may consider it acceptable to communicate on the basis of unconfirmed writes. Some programs may prefer to allow network traffic immediately. In this case, set `allowUnconfirmed` to `true` to opt out of the default behavior.
            
        -   If you want to allow some outgoing network messages to proceed immediately but not others, you can use the allowUnconfirmed option to avoid blocking the messages that you want to proceed and then separately call the [`sync()`](about:/durable-objects/api/storage-api/#sync) method, which returns a promise that only resolves once all previous writes have successfully been persisted to disk.
            
    -   `noCache` boolean
        
        -   If true, then the key/value will be discarded from memory as soon as it has completed writing to disk.
            
        -   Use `noCache` if the key will not be used again in the near future. `noCache` will never change the semantics of your code, but it may affect performance.
            
        -   If you use `get()` to retrieve the key before the write has completed, the copy from the write buffer will be returned, thus ensuring consistency with the latest call to `put()`.
            

    ### `list`

    -   `list(options Object optional)`: Promise<Map<string, any>>
        
        -   Returns all keys and values associated with the current Durable Object in ascending sorted order based on the keys' UTF-8 encodings.
            
        -   The type of each returned value in the [`Map` ↗](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) will be whatever was previously written for the corresponding key.
            
        -   Be aware of how much data may be stored in your Durable Object before calling this version of `list` without options because all the data will be loaded into the Durable Object's memory, potentially hitting its [limit](/durable-objects/platform/limits/). If that is a concern, pass options to `list` as documented below.
            

    #### Supported options

    -   `start` string
        
        -   Key at which the list results should start, inclusive.
    -   `startAfter` string
        
        -   Key after which the list results should start, exclusive. Cannot be used simultaneously with `start`.
    -   `end` string
        
        -   Key at which the list results should end, exclusive.
    -   `prefix` string
        
        -   Restricts results to only include key-value pairs whose keys begin with the prefix.
    -   `reverse` boolean
        
        -   If true, return results in descending order instead of the default ascending order.
        -   Enabling `reverse` does not change the meaning of `start`, `startKey`, or `endKey`. `start` still defines the smallest key in lexicographic order that can be returned (inclusive), effectively serving as the endpoint for a reverse-order list. `end` still defines the largest key in lexicographic order that the list should consider (exclusive), effectively serving as the starting point for a reverse-order list.
    -   `limit` number
        
        -   Maximum number of key-value pairs to return.
    -   `allowConcurrency` boolean
        
        -   Same as the option to `get()`, above.
    -   `noCache` boolean
        
        -   Same as the option to `get()`, above.

    ### `transaction`

    -   `transaction(closureFunction(txn))`: Promise
        
        -   Runs the sequence of storage operations called on `txn` in a single transaction that either commits successfully or aborts.
            
        -   Explicit transactions are no longer necessary. Any series of write operations with no intervening `await` will automatically be submitted atomically, and the system will prevent concurrent events from executing while `await` a read operation (unless you use `allowConcurrency: true`). Therefore, a series of reads followed by a series of writes (with no other intervening I/O) are automatically atomic and behave like a transaction.
            
    -   `txn`
        
        -   Provides access to the `put()`, `get()`, `delete()` and `list()` methods documented above to run in the current transaction context. In order to get transactional behavior within a transaction closure, you must call the methods on the `txn` Object instead of on the top-level `ctx.storage` Object.
            
            Also supports a `rollback()` function that ensures any changes made during the transaction will be rolled back rather than committed. After `rollback()` is called, any subsequent operations on the `txn` Object will fail with an exception. `rollback()` takes no parameters and returns nothing to the caller.
            
        
        -   When using [the SQLite-backed storage engine](about:/durable-objects/best-practices/access-durable-objects-storage/#sqlite-storage-backend), the `txn` object is obsolete. Any storage operations performed directly on the `ctx.storage` object, including SQL queries using [`ctx.storage.sql.exec()`](about:/durable-objects/api/sql-storage/#exec), will be considered part of the transaction.

    ### `transactionSync`

    -   `transactionSync(callback)`: any
        
        -   Only available when using [the SQLite-backed storage engine](about:/durable-objects/best-practices/access-durable-objects-storage/#sqlite-storage-backend).
            
        -   Invokes `callback()` wrapped in a transaction, and returns its result.
            
        -   If `callback()` throws an exception, the transaction will be rolled back.
            
        
        -   The callback must complete synchronously, that is, it should not be declared `async` nor otherwise return a Promise. Only synchronous storage operations can be part of the transaction. This is intended for use with SQL queries using [`ctx.storage.sql.exec()`](about:/durable-objects/api/sql-storage/#exec), which complete sychronously.

    ### `sync`

    -   `sync()`: Promise
        
        -   Synchronizes any pending writes to disk.
            
        -   This is similar to normal behavior from automatic write coalescing. If there are any pending writes in the write buffer (including those submitted with [the `allowUnconfirmed` option](about:/durable-objects/api/storage-api/#supported-options-1)), the returned promise will resolve when they complete. If there are no pending writes, the returned promise will be already resolved.
            

    ### `getAlarm`

    -   `getAlarm(options Object optional)`: Promise<Number | null>
        
        -   Retrieves the current alarm time (if set) as integer milliseconds since epoch. The alarm is considered to be set if it has not started, or if it has failed and any retry has not begun. If no alarm is set, `getAlarm()` returns `null`.

    #### Supported options

    -   Same options as [`get()`](about:/durable-objects/api/storage-api/#get), but without `noCache`.

    ### `setAlarm`

    -   `setAlarm(scheduledTime Date | number , options Object optional)`: Promise
        
        -   Sets the current alarm time, accepting either a JavaScript `Date`, or integer milliseconds since epoch.
            
            If `setAlarm()` is called with a time equal to or before `Date.now()`, the alarm will be scheduled for asynchronous execution in the immediate future. If the alarm handler is currently executing in this case, it will not be canceled. Alarms can be set to millisecond granularity and will usually execute within a few milliseconds after the set time, but can be delayed by up to a minute due to maintenance or failures while failover takes place.
            

    ### `deleteAlarm`

    -   `deleteAlarm(options Object optional)`: Promise
        
        -   Deletes the alarm if one exists. Does not cancel the alarm handler if it is currently executing.

    #### Supported options

    -   `setAlarm()` and `deleteAlarm()` support the same options as [`put()`](about:/durable-objects/api/storage-api/#put), but without `noCache`.

    ## Properties

    ### `sql`

    `sql` is a readonly property of type `DurableObjectStorage` encapsulating the [SQL API](/durable-objects/api/sql-storage/).

    -   [Durable Objects: Easy, Fast, Correct – Choose Three ↗](https://blog.cloudflare.com/durable-objects-easy-fast-correct-choose-three/)
    -   [WebSockets API](/durable-objects/best-practices/websockets/)

    ## Thank you for helping improve Cloudflare's documentation!
- title: SQL Storage · Cloudflare Durable Objects docs
  content: |-
    # SQL Storage · Cloudflare Durable Objects docs

    The `SqlStorage` interface encapsulates methods that modify the SQLite database embedded within a Durable Object. The `SqlStorage` interface is accessible via the `sql` property of `DurableObjectStorage` class.

    For example, using `sql.exec()`, a user can create a table, then insert rows into the table.

    ```
    import { DurableObject } from "cloudflare:workers";export class MyDurableObject extends DurableObject {  sql: SqlStorage;  constructor(ctx: DurableObjectState, env: Env) {    super(ctx, env);    this.sql = ctx.storage.sql;    this.sql.exec(`CREATE TABLE IF NOT EXISTS artist(      artistid    INTEGER PRIMARY KEY,      artistname  TEXT    );INSERT INTO artist (artistid, artistname) VALUES      (123, 'Alice'),      (456, 'Bob'),      (789, 'Charlie');`    );  }}
    ```

    Specifically for Durable Object classes with SQLite storage backend, KV operations which were previously asynchronous (for example, [`get`](about:/durable-objects/api/storage-api/#get), [`put`](about:/durable-objects/api/storage-api/#put), [`delete`](about:/durable-objects/api/storage-api/#delete), [`deleteAll`](about:/durable-objects/api/storage-api/#deleteall), [`list`](about:/durable-objects/api/storage-api/#list)) are synchronous, even though they return promises. These methods will have completed their operations before they return the promise.

    ## Methods

    ### `exec`

    `exec(query: string , ...bindings: any[] )`: SqlStorageCursor

    #### Parameters

    -   `query`: string
        -   The SQL query string to be executed. `query` can contain `?` placeholders for parameter bindings. Multiple SQL statements, separated with a semicolon, can be executed in the `query`. With multiple SQL statements, any parameter bindings are applied to the last SQL statement in the `query`, and the returned cursor is only for the last SQL statement.
    -   `bindings`: any\[\] Optional
        -   Optional variable number of arguments that correspond to the `?` placeholders in `query`.

    #### Returns

    A cursor (`SqlStorageCursor`) to iterate over query row results as objects. `SqlStorageCursor` is a JavaScript [Iterable ↗](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol), which supports iteration using `for (let row of cursor)`. `SqlStorageCursor` is also a JavaScript [Iterator ↗](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol), which supports iteration using `cursor.next()`.

    `SqlStorageCursor` supports the following methods:

    -   `next()`
        -   Returns an object representing the next value of the cursor. The returned object has `done` and `value` properties adhering to the JavaScript [Iterator ↗](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol). `done` is set to `false` when a next value is present, and `value` is set to the next row object in the query result. `done` is set to `true` when the entire cursor is consumed, and no `value` is set.
    -   `toArray()`
        -   Iterates through remaining cursor value(s) and returns an array of returned row objects.
    -   `one()`
        -   Returns a row object if query result has exactly one row. If query result has zero rows or more than one row, `one()` throws an exception.
    -   `raw()`: Iterator
        -   Returns an Iterator over the same query results, with each row as an array of column values (with no column names) rather than an object.
        -   Returned Iterator supports `next()`, `toArray()`, and `one()` methods above.
        -   Returned cursor and `raw()` iterator iterate over the same query results and can be combined. For example:

    ```
    let cursor = this.sql.exec("SELECT * FROM artist ORDER BY artistname ASC;");let rawResult = cursor.raw().next();if (!rawResult.done) {  console.log(rawResult.value); // prints [ 123, 'Alice' ]} else {  // query returned zero results}console.log(cursor.toArray()); // prints [{ artistid: 456, artistname: 'Bob' },{ artistid: 789, artistname: 'Charlie' }]
    ```

    `SqlStorageCursor` had the following properties:

    -   `columnNames`: string\[\]
        -   The column names of the query in the order they appear in each row array returned by the `raw` iterator.
    -   `rowsRead`: number
    -   The number of rows read so far as part of this SQL `query`. This may increase as you iterate the cursor. The final value is used for [SQL billing](about:/durable-objects/platform/pricing/#sqlite-storage-backend).
    -   `rowsWritten`: number
    -   The number of rows written so far as part of this SQL `query`. This may increase as you iterate the cursor. The final value is used for [SQL billing](about:/durable-objects/platform/pricing/#sqlite-storage-backend).

    Note that `sql.exec()` cannot execute transaction-related statements like `BEGIN TRANSACTION` or `SAVEPOINT`. Instead, use the [`ctx.storage.transaction()`](#transaction) or [`ctx.storage.transactionSync()`](#transactionsync) APIs to start a transaction, and then execute SQL queries in your callback.

    #### Examples

    [SQL API](about:/durable-objects/api/sql-storage/#exec) examples below use the following SQL schema:

    ```
    import { DurableObject } from "cloudflare:workers";export class MyDurableObject extends DurableObject {  sql: SqlStorage  constructor(ctx: DurableObjectState, env: Env) {    super(ctx, env);    this.sql = ctx.storage.sql;    this.sql.exec(`CREATE TABLE IF NOT EXISTS artist(      artistid    INTEGER PRIMARY KEY,      artistname  TEXT    );INSERT INTO artist (artistid, artistname) VALUES      (123, 'Alice'),      (456, 'Bob'),      (789, 'Charlie');`    );  }}
    ```

    Iterate over query results as row objects:

    ```
      let cursor = this.sql.exec("SELECT * FROM artist;");  for (let row of cursor) {    // Iterate over row object and do something  }
    ```

    Convert query results to an array of row objects:

    ```
      // Return array of row objects: [{"artistid":123,"artistname":"Alice"},{"artistid":456,"artistname":"Bob"},{"artistid":789,"artistname":"Charlie"}]  let resultsArray1 = this.sql.exec("SELECT * FROM artist;").toArray();  // OR  let resultsArray2 = Array.from(this.sql.exec("SELECT * FROM artist;"));  // OR  let resultsArray3 = [...this.sql.exec("SELECT * FROM artist;")]; // JavaScript spread syntax
    ```

    Convert query results to an array of row values arrays:

    ```
      // Returns [[123,"Alice"],[456,"Bob"],[789,"Charlie"]]  let cursor = this.sql.exec("SELECT * FROM artist;");  let resultsArray = cursor.raw().toArray();  // Returns ["artistid","artistname"]  let columnNameArray = this.sql.exec("SELECT * FROM artist;").columnNames.toArray();
    ```

    Get first row object of query results:

    ```
      // Returns {"artistid":123,"artistname":"Alice"}  let firstRow = this.sql.exec("SELECT * FROM artist ORDER BY artistname DESC;").toArray()[0];
    ```

    Check if query results have exactly one row:

    ```
      // returns error  this.sql.exec("SELECT * FROM artist ORDER BY artistname ASC;").one();  // returns { artistid: 123, artistname: 'Alice' }  let oneRow = this.sql.exec("SELECT * FROM artist WHERE artistname = ?;", "Alice").one()
    ```

    Returned cursor behavior:

    ```
      let cursor = this.sql.exec("SELECT * FROM artist ORDER BY artistname ASC;");  let result = cursor.next();  if (!result.done) {    console.log(result.value); // prints { artistid: 123, artistname: 'Alice' }  } else {    // query returned zero results  }  let remainingRows = cursor.toArray();  console.log(remainingRows); // prints [{ artistid: 456, artistname: 'Bob' },{ artistid: 789, artistname: 'Charlie' }]
    ```

    Returned cursor and `raw()` iterator iterate over the same query results:

    ```
      let cursor = this.sql.exec("SELECT * FROM artist ORDER BY artistname ASC;");  let result = cursor.raw().next();  if (!result.done) {    console.log(result.value); // prints [ 123, 'Alice' ]  } else {    // query returned zero results  }  console.log(cursor.toArray()); // prints [{ artistid: 456, artistname: 'Bob' },{ artistid: 789, artistname: 'Charlie' }]
    ```

    `sql.exec().rowsRead()`:

    ```
      let cursor = this.sql.exec("SELECT * FROM artist;");  cursor.next()  console.log(cursor.rowsRead); // prints 1  cursor.toArray(); // consumes remaining cursor  console.log(cursor.rowsRead); // prints 3
    ```

    ### `databaseSize`

    `databaseSize`: number

    #### Returns

    The current SQLite database size in bytes.

    ```
    let size = ctx.storage.sql.databaseSize;
    ```

    ## Point in time recovery

    For [Durable Objects classes with SQL storage](about:/durable-objects/reference/durable-objects-migrations/#enable-sqlite-storage-backend-on-new-durable-object-class-migration), the following point-in-time-recovery (PITR) API methods are available to restore a Durable Object's embedded SQLite database to any point in time in the past 30 days. These methods apply to the entire SQLite database contents, including both the object's stored SQL data and stored key-value data using the key-value `put()` API. The PITR API is not supported in local development because a durable log of data changes is not stored locally.

    The PITR API represents points in times using 'bookmarks'. A bookmark is a mostly alphanumeric string like `0000007b-0000b26e-00001538-0c3e87bb37b3db5cc52eedb93cd3b96b`. Bookmarks are designed to be lexically comparable: a bookmark representing an earlier point in time compares less than one representing a later point, using regular string comparison.

    ### `getCurrentBookmark`

    `ctx.storage.getCurrentBookmark()`: Promise<string>

    -   Returns a bookmark representing the current point in time in the object's history.

    ### `getBookmarkForTime`

    `ctx.storage.getBookmarkForTime(timestamp: number | Date )`: Promise<string>

    -   Returns a bookmark representing approximately the given point in time, which must be within the last 30 days. If the timestamp is represented as a number, it is converted to a date as if using `new Date(timestamp)`.

    ### `onNextSessionRestoreBookmark`

    `ctx.storage.onNextSessionRestoreBookmark(bookmark: string )`: Promise<string>

    -   Configures the Durable Object so that the next time it restarts, it should restore its storage to exactly match what the storage contained at the given bookmark. After calling this, the application should typically invoke `ctx.abort()` to restart the Durable Object, thus completing the point-in-time recovery.

    This method returns a special bookmark representing the point in time immediately before the recovery takes place (even though that point in time is still technically in the future). Thus, after the recovery completes, it can be undone by performing a second recovery to this bookmark.

    ```
    let now = new Date();// restore to 2 days agolet bookmark = ctx.storage.getBookmarkForTime(now - 2);ctx.storage.onNextSessionRestoreBookmark(bookmark);
    ```

    ## Thank you for helping improve Cloudflare's documentation!
- title: Alarms · Cloudflare Durable Objects docs
  content: >-
    # Alarms · Cloudflare Durable Objects docs


    ## Background


    Durable Objects alarms allow you to schedule the Durable Object to be woken
    up at a time in the future. When the alarm's scheduled time comes, the
    `alarm()` handler method will be called. Alarms are modified using the
    Storage API, and alarm operations follow the same rules as other storage
    operations.


    Notably:


    -   Each Durable Object is able to schedule a single alarm at a time by
    calling `setAlarm()`.

    -   Alarms have guaranteed at-least-once execution and are retried
    automatically when the `alarm()` handler throws.

    -   Retries are performed using exponential backoff starting at a 2 second
    delay from the first failure with up to 6 retries allowed.


    Alarms can be used to build distributed primitives, like queues or batching
    of work atop Durable Objects. Alarms also provide a mechanism to guarantee
    that operations within a Durable Object will complete without relying on
    incoming requests to keep the Durable Object alive. For a complete example,
    refer to [Use the Alarms API](/durable-objects/examples/alarms-api/).


    ## Storage methods


    ### `getAlarm`


    -   `getAlarm()`: number | null
        
        -   If there is an alarm set, then return the currently set alarm time as the number of milliseconds elapsed since the UNIX epoch. Otherwise, return `null`.

    ### `setAlarm`


    -   `setAlarm(scheduledTimeMs number )` : void
        
        -   Set the time for the alarm to run. Specify the time as the number of milliseconds elapsed since the UNIX epoch.

    ### `deleteAlarm`


    -   `deleteAlarm()`: void
        
        -   Unset the alarm if there is a currently set alarm.
            
        -   Calling `deleteAlarm()` inside the `alarm()` handler may prevent retries on a best-effort basis, but is not guaranteed.

            

    ## Handler methods


    ### `alarm`


    -   `alarm()`: void
        
        -   Called by the system when a scheduled alarm time is reached.
            
        -   The `alarm()` handler has guaranteed at-least-once execution and will be retried upon failure using exponential backoff, starting at 2 second delays for up to 6 retries. Retries will be performed if the method fails with an uncaught exception.
            
        -   This method can be `async`.

            

    ## Example


    This example shows how to both set alarms with the `setAlarm(timestamp)`
    method and handle alarms with the `alarm()` handler within your Durable
    Object.


    -   The `alarm()` handler will be called once every time an alarm fires.

    -   If an unexpected error terminates the Durable Object, the `alarm()`
    handler may be re-instantiated on another machine.

    -   Following a short delay, the `alarm()` handler will run from the
    beginning on the other machine.


    ```

    import { DurableObject } from "cloudflare:workers";export default {  async
    fetch(request, env) {    let id =
    env.ALARM_EXAMPLE.idFromName("foo");    return await
    env.ALARM_EXAMPLE.get(id).fetch(request);  },};const SECONDS = 1000;export
    class AlarmExample extends DurableObject {  constructor(ctx, env)
    {    this.ctx = ctx;    this.storage = ctx.storage;  }  async fetch(request)
    {    // If there is no alarm currently set, set one for 10 seconds from
    now    let currentAlarm = await this.storage.getAlarm();    if (currentAlarm
    == null) {      this.storage.setAlarm(Date.now() + 10 *
    SECONDS);    }  }  async alarm() {    // The alarm handler will be invoked
    whenever an alarm fires.    // You can use this to do work, read from the
    Storage API, make HTTP calls    // and set future alarms to run using
    this.storage.setAlarm() from within this handler.  }}

    ```


    -   Understand how to [use the Alarms
    API](/durable-objects/examples/alarms-api/) in an end-to-end example.

    -   Read the [Durable Objects alarms announcement blog post
    ↗](https://blog.cloudflare.com/durable-objects-alarms/).

    -   Review the [Storage API](/durable-objects/api/storage-api/)
    documentation for Durable Objects.


    ## Thank you for helping improve Cloudflare's documentation!
- title: WebGPU · Cloudflare Durable Objects docs
  content: |-
    # WebGPU · Cloudflare Durable Objects docs

    The [WebGPU API ↗](https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API) allows you to use the GPU directly from JavaScript.

    The WebGPU API is only accessible from within [Durable Objects](/durable-objects/). You cannot use the WebGPU API from within Workers.

    To use the WebGPU API in local development, enable the `experimental` and `webgpu` [compatibility flags](/workers/configuration/compatibility-flags/) in the [`wrangler.toml` configuration file](/workers/wrangler/configuration/) of your Durable Object.

    ```
    compatibility_flags = ["experimental", "webgpu"]
    ```

    The following subset of the WebGPU API is available from within Durable Objects:

    | API | Supported? | Notes |
    | --- | --- | --- |
    | [`navigator.gpu` ↗](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/gpu) | ✅ |  |
    | [`GPU.requestAdapter` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPU/requestAdapter) | ✅ |  |
    | [`GPUAdapterInfo` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUAdapterInfo) | ✅ |  |
    | [`GPUAdapter` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUAdapter) | ✅ |  |
    | [`GPUBindGroupLayout` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroupLayout) | ✅ |  |
    | [`GPUBindGroup` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUBindGroup) | ✅ |  |
    | [`GPUBuffer` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUBuffer) | ✅ |  |
    | [`GPUCommandBuffer` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUCommandBuffer) | ✅ |  |
    | [`GPUCommandEncoder` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUCommandEncoder) | ✅ |  |
    | [`GPUComputePassEncoder` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUComputePassEncoder) | ✅ |  |
    | [`GPUComputePipeline` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUComputePipeline) | ✅ |  |
    | [`GPUComputePipelineError` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUPipelineError) | ✅ |  |
    | [`GPUDevice` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice) | ✅ |  |
    | [`GPUOutOfMemoryError` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUOutOfMemoryError) | ✅ |  |
    | [`GPUValidationError` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUValidationError) | ✅ |  |
    | [`GPUInternalError` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUInternalError) | ✅ |  |
    | [`GPUDeviceLostInfo` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUDeviceLostInfo) | ✅ |  |
    | [`GPUPipelineLayout` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUPipelineLayout) | ✅ |  |
    | [`GPUQuerySet` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUQuerySet) | ✅ |  |
    | [`GPUQueue` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUQueue) | ✅ |  |
    | [`GPUSampler` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUSampler) | ✅ |  |
    | [`GPUCompilationMessage` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUCompilationMessage) | ✅ |  |
    | [`GPUShaderModule` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUShaderModule) | ✅ |  |
    | [`GPUSupportedFeatures` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUSupportedFeatures) | ✅ |  |
    | [`GPUSupportedLimits` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUSupportedLimits) | ✅ |  |
    | [`GPUMapMode` ↗](https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API#reading_the_results_back_to_javascript) | ✅ |  |
    | [`GPUShaderStage` ↗](https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API#create_a_bind_group_layout) | ✅ |  |
    | [`GPUUncapturedErrorEvent` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUUncapturedErrorEvent) | ✅ |  |

    The following subset of the WebGPU API is not yet supported:

    | API | Supported? | Notes |
    | --- | --- | --- |
    | [`GPU.getPreferredCanvasFormat` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPU/getPreferredCanvasFormat) |  |  |
    | [`GPURenderBundle` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPURenderBundle) |  |  |
    | [`GPURenderBundleEncoder` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPURenderBundleEncoder) |  |  |
    | [`GPURenderPassEncoder` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPURenderPassEncoder) |  |  |
    | [`GPURenderPipeline` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPURenderPipeline) |  |  |
    | [`GPUShaderModule` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUShaderModule) |  |  |
    | [`GPUTexture` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUTexture) |  |  |
    | [`GPUTextureView` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUTextureView) |  |  |
    | [`GPUExternalTexture` ↗](https://developer.mozilla.org/en-US/docs/Web/API/GPUExternalTexture) |  |  |

    ## Examples

    -   [workers-wonnx ↗](https://github.com/cloudflare/workers-wonnx/) — Image classification, running on a GPU via the WebGPU API, using the [wonnx ↗](https://github.com/webonnx/wonnx) model inference runtime.

    ## Was this helpful?

    Yes No

    ## What did you like?

    Accurate

    Easy to understand

    Solved my problem

    Helped me decide to use the product

    Other

    ## What went wrong?

    Hard to understand

    Incorrect information

    Missing the information

    Other

    ## Thank you for helping improve Cloudflare's documentation!
- title: Troubleshooting · Cloudflare Durable Objects docs
  content: |-
    # Troubleshooting · Cloudflare Durable Objects docs

    ## Debugging

    [`wrangler dev`](about:/workers/wrangler/commands/#dev) and [`wrangler tail`](about:/workers/wrangler/commands/#tail) are both available to help you debug your Durable Objects.

    The `wrangler dev` command opens a tunnel from your local development environment to Cloudflare's global network, letting you test your Durable Objects code in the Workers environment as you write it.

    `wrangler tail` displays a live feed of console and exception logs for each request served by your Worker code, including both normal Worker requests and Durable Object requests. After running `npx wrangler deploy`, you can use `wrangler tail` in the root directory of your Worker project and visit your Worker URL to see console and error logs in your terminal.

    ## Common errors

    ### No event handlers were registered. This script does nothing.

    In your `wrangler.toml` file, make sure the `dir` and `main` entries point to the correct file containing your Worker code, and that the file extension is `.mjs` instead of `.js` if using ES modules syntax.

    ### Cannot apply `--delete-class` migration to class.

    When deleting a migration using `npx wrangler deploy --delete-class <ClassName>`, you may encounter this error: `"Cannot apply --delete-class migration to class <ClassName> without also removing the binding that references it"`. You should remove the corresponding binding under `[durable_objects]` in `wrangler.toml` before attempting to apply `--delete-class` again.

    ### Durable Object is overloaded.

    A single instance of a Durable Object cannot do more work than is possible on a single thread. These errors mean the Durable Object has too much work to keep up with incoming requests:

    -   `Error: Durable Object is overloaded. Too many requests queued.` The total count of queued requests is too high.
    -   `Error: Durable Object is overloaded. Too much data queued.` The total size of data in queued requests is too high.
    -   `Error: Durable Object is overloaded. Requests queued for too long.` The oldest request has been in the queue too long.
    -   `Error: Durable Object is overloaded. Too many requests for the same object within a 10 second window.` The number of requests for a Durable Object is too high within a short span of time (10 seconds). This error indicates a more extreme level of overload.

    To solve this error, you can either do less work per request, or send fewer requests. For example, you can split the requests among more instances of the Durable Object.

    These errors and others that are due to overload will have an [`.overloaded` property](/durable-objects/best-practices/error-handling) set on their exceptions, which can be used to avoid retrying overloaded operations.

    ### Your account is generating too much load on Durable Objects. Please back off and try again later.

    There is a limit on how quickly you can create new [stubs](/durable-objects/api/stub) for new or existing Durable Objects. Those lookups are usually cached, meaning attempts for the same set of recently accessed Durable Objects should be successful, so catching this error and retrying after a short wait is safe. If possible, also consider spreading those lookups across multiple requests.

    ### Durable Object reset because its code was updated.

    Reset in error messages refers to in-memory state. Any durable state that has already been successfully persisted via `state.storage` is not affected.

    Refer to [Global Uniqueness](about:/durable-objects/platform/known-issues/#global-uniqueness).

    ### Durable Object storage operation exceeded timeout which caused object to be reset.

    To prevent indefinite blocking, there is a limit on how much time storage operations can take. In Durable Objects containing a sufficiently large number of key-value pairs, `deleteAll()` may hit that time limit and fail. When this happens, note that each `deleteAll()` call does make progress and that it is safe to retry until it succeeds. Otherwise contact [Cloudflare support](/support/contacting-cloudflare-support/).

    ### Your account is doing too many concurrent storage operations. Please back off and try again later.

    Besides the suggested approach of backing off, also consider changing your code to use `state.storage.get(keys Array<string>)` rather than multiple individual `state.storage.get(key)` calls where possible.

    ## Thank you for helping improve Cloudflare's documentation!
- title: Metrics and GraphQL analytics · Cloudflare Durable Objects docs
  content: |-
    # Metrics and GraphQL analytics · Cloudflare Durable Objects docs

    Durable Objects expose analytics for Durable Object namespace-level and request-level metrics.

    The metrics displayed in the [Cloudflare dashboard ↗](https://dash.cloudflare.com/) charts are queried from Cloudflare’s [GraphQL Analytics API](/analytics/graphql-api/). You can access the metrics [programmatically via GraphQL](#query-via-the-graphql-api) or HTTP client.

    ## View metrics and analytics via the dashboard

    Per-namespace analytics for Durable Objects are available in the Cloudflare dashboard. To view current and historical metrics for a namespace:

    1.  Log in to the [Cloudflare dashboard ↗](https://dash.cloudflare.com/) and select your account.
    2.  Go to [**Workers & Pages** > **Durable Objects** ↗](https://dash.cloudflare.com/?to=/:account/workers/durable-objects).
    3.  View account-level Durable Objects usage.
    4.  Select an existing namespace.
    5.  Select the **Metrics** tab.

    You can optionally select a time window to query. This defaults to the last 24 hours.

    ## Query via the GraphQL API

    Durable Object metrics are powered by GraphQL.

    The datasets that include Durable Object metrics include:

    -   `durableObjectsInvocationsAdaptiveGroups`
    -   `durableObjectsPeriodicGroups`
    -   `durableObjectsStorageGroups`
    -   `durableObjectsSubrequestsAdaptiveGroups`

    Use [GraphQL Introspection](/analytics/graphql-api/features/discovery/introspection/) to get information on the fields exposed by each datasets.

    ### WebSocket metrics

    Durable Objects using [WebSockets](/durable-objects/best-practices/websockets/) will see request metrics across several GraphQL datasets because WebSockets have different types of requests.

    -   Metrics for a WebSocket connection itself is represented in `durableObjectsInvocationsAdaptiveGroups` once the connection closes. Since WebSocket connections are long-lived, connections often do not terminate until the Durable Object terminates.
    -   Metrics for incoming and outgoing WebSocket messages on a WebSocket connection are available in `durableObjectsPeriodicGroups`. If a WebSocket connection uses [WebSocket Hibernation](about:/durable-objects/best-practices/websockets/#websocket-hibernation-api), incoming WebSocket messages are instead represented in `durableObjectsInvocationsAdaptiveGroups`.

    ## Example GraphQL query for Durable Objects

    ```
      viewer {    /*    Replace with your account tag, the 32 hex character id visible at the beginning of any url    when logged in to dash.cloudflare.com or under "Account ID" on the sidebar of the Workers & Pages Overview    */    accounts(filter: {accountTag: "your account tag here"}) {      // Replace dates with a recent date      durableObjectsInvocationsAdaptiveGroups(filter: {date_gt: "2023-05-23"}, limit: 1000) {        sum {          // Any other fields found through introspection can be added here          requests          responseBodySize        }      }      durableObjectsPeriodicGroups(filter: {date_gt: "2023-05-23"}, limit: 1000) {        sum {          cpuTime        }      }      durableObjectsStorageGroups(filter: {date_gt: "2023-05-23"}, limit: 1000) {        max {          storedBytes        }      }    }  }
    ```

    Refer to the [Querying Workers Metrics with GraphQL](/analytics/graphql-api/tutorials/querying-workers-metrics/) tutorial for authentication and to learn more about querying Workers datasets.

    ## Thank you for helping improve Cloudflare's documentation!
- title: Build a rate limiter · Cloudflare Durable Objects docs
  content: |-
    # Build a rate limiter · Cloudflare Durable Objects docs

    Build a rate limiter using Durable Objects and Workers.

    This example shows how to build a rate limiter using Durable Objects and Workers that can be used to protect upstream resources, including third-party APIs that your application relies on and/or services that may be costly for you to invoke.

    This example also discusses some decisions that need to be made when designing a system, such as a rate limiter, with Durable Objects.

    The Worker creates a `RateLimiter` Durable Object on a per IP basis to protect upstream resources. IP based rate limiting can be effective without negatively impacting latency because any given IP will remain within a small geographic area colocated with the `RateLimiter` Durable Object. Furthermore, throughput is also improved because each IP gets its own Durable Object.

    It might seem simpler to implement a global rate limiter, `const id = env.RATE_LIMITER.idFromName("global");`, which can provide better guarantees on the request rate to the upstream resource. However:

    -   This would require all requests globally to make a sub-request to a single Durable Object.
    -   Implementing a global rate limiter would add additional latency for requests not colocated with the Durable Object, and global throughput would be capped to the throughput of a single Durable Object.
    -   A single Durable Object that all requests rely on is typically considered an anti-pattern. Durable Objects work best when they are scoped to a user, room, service and/or the specific subset of your application that requires global co-ordination.

    The Durable Object uses a token bucket algorithm to implement rate limiting. The naive idea is that each request requires a token to complete, and the tokens are replenished according to the reciprocal of the desired number of requests per second. As an example, a 1000 requests per second rate limit will have a token replenished every millisecond (as specified by milliseconds\_per\_request) up to a given capacity limit.

    This example uses Durable Object's [Alarms API](/durable-objects/api/alarms) to schedule the Durable Object to be woken up at a time in the future.

    -   When the alarm's scheduled time comes, the `alarm()` handler method is called, and in this case, the alarm will add a token to the "Bucket".
    -   The implementation is made more efficient by adding tokens in bulk (as specified by milliseconds\_for\_updates) and preventing the alarm handler from being invoked every millisecond. More frequent invocations of Durable Objects will lead to higher invocation and duration charges.

    The first implementation of a rate limiter is below:

    -   [JavaScript](#tab-panel-1429)
    -   [TypeScript](#tab-panel-1430)

    ```
    import { DurableObject } from "cloudflare:workers";// Workerexport default {  async fetch(request, env, _ctx) {    // Determine the IP address of the client    const ip = request.headers.get("CF-Connecting-IP");    if (ip === null) {      return new Response("Could not determine client IP", { status: 400 });    }    // Obtain an identifier for a Durable Object based on the client's IP address    const id = env.RATE_LIMITER.idFromName(ip);    try {      const stub = env.RATE_LIMITER.get(id);      const milliseconds_to_next_request = await stub.getMillisecondsToNextRequest();      if (milliseconds_to_next_request > 0) {        // Alternatively one could sleep for the necessary length of time        return new Response("Rate limit exceeded", { status: 429 });      }    } catch (error) {      return new Response("Could not connect to rate limiter", { status: 502 });    }    // TODO: Implement me    return new Response("Call some upstream resource...")  }};// Durable Objectexport class RateLimiter extends DurableObject {  static milliseconds_per_request = 1;  static milliseconds_for_updates = 5000;  static capacity = 10000;  constructor(ctx, env) {    super(ctx, env);    this.tokens = RateLimiter.capacity;  }  async getMillisecondsToNextRequest() {    this.checkAndSetAlarm()    let milliseconds_to_next_request = RateLimiter.milliseconds_per_request;    if (this.tokens > 0) {      this.tokens -= 1;      milliseconds_to_next_request = 0;    }    return milliseconds_to_next_request;  }  async checkAndSetAlarm() {    let currentAlarm = await this.ctx.storage.getAlarm();    if (currentAlarm == null) {      this.ctx.storage.setAlarm(Date.now() +        RateLimiter.milliseconds_for_updates * RateLimiter.milliseconds_per_request);    }  }  async alarm() {    if (this.tokens < RateLimiter.capacity) {      this.tokens = Math.min(RateLimiter.capacity,        this.tokens + RateLimiter.milliseconds_for_updates);      this.checkAndSetAlarm()    }  }}
    ```

    While the token bucket algorithm is popular for implementing rate limiting and uses Durable Object features, there is a simpler approach:

    -   [JavaScript](#tab-panel-1431)
    -   [TypeScript](#tab-panel-1432)

    ```
    import { DurableObject } from "cloudflare:workers";// Durable Objectexport class RateLimiter extends DurableObject {  static milliseconds_per_request = 1;  static milliseconds_for_grace_period = 5000;  constructor(ctx, env) {    super(ctx, env);    this.nextAllowedTime = 0;  }  async getMillisecondsToNextRequest() {    const now = Date.now();    this.nextAllowedTime = Math.max(now, this.nextAllowedTime);    this.nextAllowedTime += RateLimiter.milliseconds_per_request;    const value = Math.max(0,      this.nextAllowedTime - now - RateLimiter.milliseconds_for_grace_period);    return value;  }}
    ```

    Finally, configure your `wrangler.toml` file to include a Durable Object [binding](about:/durable-objects/get-started/#5-configure-durable-object-bindings) and [migration](/durable-objects/reference/durable-objects-migrations/) based on the namespace and class name chosen previously.

    -   [wrangler.toml](#tab-panel-1433)
    -   [wrangler.json](#tab-panel-1434)

    ```
    name = "my-counter"[[durable_objects.bindings]]name = "RATE_LIMITER"class_name = "RateLimiter"[[migrations]]tag = "v1"new_classes = ["RateLimiter"]
    ```

    -   Learn more about Durable Object's [Alarms API](/durable-objects/api/alarms) and how to configure alarms.
    -   [Understand how to troubleshoot](/durable-objects/observability/troubleshooting/) common errors related with Durable Objects.
    -   Review how [Durable Objects are priced](/durable-objects/platform/pricing/), including pricing examples.

    ## Thank you for helping improve Cloudflare's documentation!
- title: Build a WebSocket server · Cloudflare Durable Objects docs
  content: >-
    # Build a WebSocket server · Cloudflare Durable Objects docs


    ```

    import { DurableObject } from "cloudflare:workers";// Workerexport default
    {  async fetch(request, env, ctx) {    if
    (request.url.endsWith("/websocket")) {      // Expect to receive a WebSocket
    Upgrade request.      // If there is one, accept the request and return a
    WebSocket Response.      const upgradeHeader =
    request.headers.get('Upgrade');      if (!upgradeHeader || upgradeHeader !==
    'websocket') {        return new Response('Durable Object expected Upgrade:
    websocket', { status: 426 });      }      // This example will refer to the
    same Durable Object,      // since the name "foo" is hardcoded.      let id
    = env.WEBSOCKET_SERVER.idFromName("foo");      let stub =
    env.WEBSOCKET_SERVER.get(id);      return
    stub.fetch(request);    }    return new Response(null, {      status:
    400,      statusText: 'Bad Request',      headers: {        'Content-Type':
    'text/plain',      },    });  }};// Durable Objectexport class
    WebSocketServer extends DurableObject
    {  currentlyConnectedWebSockets;  constructor(ctx, env) {    // This is
    reset whenever the constructor runs because    // regular WebSockets do not
    survive Durable Object resets.    //    // WebSockets accepted via the
    Hibernation API can survive    // a certain type of eviction, but we will
    not cover that here.    super(ctx,
    env);    this.currentlyConnectedWebSockets = 0;  }  async fetch(request)
    {    // Creates two ends of a WebSocket connection.    const webSocketPair =
    new WebSocketPair();    const [client, server] =
    Object.values(webSocketPair);    // Calling `accept()` tells the runtime
    that this WebSocket is to begin terminating    // request within the Durable
    Object. It has the effect of "accepting" the connection,    // and allowing
    the WebSocket to send and receive
    messages.    server.accept();    this.currentlyConnectedWebSockets +=
    1;    // Upon receiving a message from the client, the server replies with
    the same message,    // and the total number of connections with the
    "[Durable Object]: " prefix    server.addEventListener('message', (event) =>
    {      server.send(`[Durable Object] currentlyConnectedWebSockets:
    ${this.currentlyConnectedWebSockets}`);    });    // If the client closes
    the connection, the runtime will close the connection
    too.    server.addEventListener('close', (cls) =>
    {      this.currentlyConnectedWebSockets -= 1;      server.close(cls.code,
    "Durable Object is closing WebSocket");    });    return new Response(null,
    {      status: 101,      webSocket: client,    });  }}

    ```
- title: Build a counter · Cloudflare Durable Objects docs
  content: >-
    # Build a counter · Cloudflare Durable Objects docs


    ```

    import { DurableObject } from "cloudflare:workers";// Workerexport default
    {  async fetch(request, env) {    let url = new URL(request.url);    let
    name = url.searchParams.get("name");    if (!name) {      return new
    Response(        "Select a Durable Object to contact by using" +          "
    the `name` URL query string parameter, for example,
    ?name=A"      );    }    // Every unique ID refers to an individual instance
    of the Counter class that    // has its own state. `idFromName()` always
    returns the same ID when given the    // same string as input (and called on
    the same class), but never the same    // ID for two different strings (or
    for different classes).    let id = env.COUNTERS.idFromName(name);    //
    Construct the stub for the Durable Object using the ID.    // A stub is a
    client Object used to send messages to the Durable Object.    let stub =
    env.COUNTERS.get(id);    // Send a request to the Durable Object using RPC
    methods, then await its response.    let count = null;    switch
    (url.pathname) {      case "/increment":        count = await
    stub.increment();        break;      case "/decrement":        count = await
    stub.decrement();        break;      case "/":        // Serves the current
    value.        count = await
    stub.getCounterValue();        break;      default:        return new
    Response("Not found", { status: 404 });    }    return new Response(`Durable
    Object '${name}' count: ${count}`);  }};// Durable Objectexport class
    Counter extends DurableObject {  async getCounterValue() {    let value =
    (await this.ctx.storage.get("value")) || 0;    return value;  }  async
    increment(amount = 1) {    let value = (await this.ctx.storage.get("value"))
    || 0;    value += amount;    // You do not have to worry about a concurrent
    request having modified the value in storage.    // "input gates" will
    automatically protect against unwanted concurrency.    // Read-modify-write
    is safe.    await this.ctx.storage.put("value", value);    return
    value;  }  async decrement(amount = 1) {    let value = (await
    this.ctx.storage.get("value")) || 0;    value -= amount;    await
    this.ctx.storage.put("value", value);    return value;  }}

    ```
- title: Durable Object in-memory state · Cloudflare Durable Objects docs
  content: |-
    # Durable Object in-memory state · Cloudflare Durable Objects docs

    This example shows you how Durable Objects are stateful, meaning in-memory state can be retained between requests. After a brief period of inactivity, the Durable Object will be evicted, and all in-memory state will be lost. The next request will reconstruct the object, but instead of showing the city of the previous request, it will display a message indicating that the object has been reinitialized. If you need your applications state to survive eviction, write the state to storage by using the [Storage API](/durable-objects/api/storage-api/), or by storing your data elsewhere.

    ```
    import { DurableObject } from 'cloudflare:workers';// Workerexport default {  async fetch(request, env) {    return await handleRequest(request, env);  }}async function handleRequest(request, env) {  let id = env.LOCATION.idFromName("A");  let obj = env.LOCATION.get(id);  // Forward the request to the remote Durable Object.  let resp = await obj.fetch(request);  // Return the response to the client.  return new Response(await resp.text());}// Durable Objectexport class Location extends DurableObject {  constructor(state, env) {    this.state = state;    // Upon construction, you do not have a location to provide.    // This value will be updated as people access the Durable Object.    // When the Durable Object is evicted from memory, this will be reset.    this.location = null  }  // Handle HTTP requests from clients.  async fetch(request) {    let response = null    if (this.location == null) {      response = new String(`This is the first request, you called the constructor, so this.location was null.You will set this.location to be your city: (${request.cf.city}). Try reloading the page.`);    } else {      response = new String(`The Durable Object was already loaded and running because it recently handled a request.Previous Location: ${this.location}New Location: ${request.cf.city}`);    }    // You set the new location to be the new city.    this.location = request.cf.city;    console.log(response);    return new Response(response);  }}
    ```

    Finally, configure your `wrangler.toml` file to include a Durable Object [binding](about:/durable-objects/get-started/#5-configure-durable-object-bindings) and [migration](/durable-objects/reference/durable-objects-migrations/) based on the namespace and class name chosen previously.

    -   [wrangler.toml](#tab-panel-1441)
    -   [wrangler.json](#tab-panel-1442)

    ```
    name = "durable-object-in-memory-state"[[durable_objects.bindings]]name = "LOCATION"class_name = "Location"[[migrations]]tag = "v1"new_classes = ["Location"]
    ```

    ## Thank you for helping improve Cloudflare's documentation!
- title: Build a WebSocket server with WebSocket Hibernation · Cloudflare Durable
    Objects docs
  content: >-
    # Build a WebSocket server with WebSocket Hibernation · Cloudflare Durable
    Objects docs


    ```

    import { DurableObject } from "cloudflare:workers";// Workerexport default
    {  async fetch(request, env, ctx) {    if
    (request.url.endsWith("/websocket")) {      // Expect to receive a WebSocket
    Upgrade request.      // If there is one, accept the request and return a
    WebSocket Response.      const upgradeHeader =
    request.headers.get('Upgrade');      if (!upgradeHeader || upgradeHeader !==
    'websocket') {        return new Response('Durable Object expected Upgrade:
    websocket', { status: 426 });      }      // This example will refer to the
    same Durable Object,      // since the name "foo" is hardcoded.      let id
    = env.WEBSOCKET_HIBERNATION_SERVER.idFromName("foo");      let stub =
    env.WEBSOCKET_HIBERNATION_SERVER.get(id);      return
    stub.fetch(request);    }    return new Response(null, {      status:
    400,      statusText: 'Bad Request',      headers: {        'Content-Type':
    'text/plain',      },    });  }};// Durable Objectexport class
    WebSocketHibernationServer extends DurableObject {  async fetch(request)
    {    // Creates two ends of a WebSocket connection.    const webSocketPair =
    new WebSocketPair();    const [client, server] =
    Object.values(webSocketPair);    // Calling `acceptWebSocket()` informs the
    runtime that this WebSocket is to begin terminating    // request within the
    Durable Object. It has the effect of "accepting" the connection,    // and
    allowing the WebSocket to send and receive messages.    // Unlike
    `ws.accept()`, `state.acceptWebSocket(ws)` informs the Workers Runtime that
    the WebSocket    // is "hibernatable", so the runtime does not need to pin
    this Durable Object to memory while    // the connection is open. During
    periods of inactivity, the Durable Object can be evicted    // from memory,
    but the WebSocket connection will remain open. If at some later point
    the    // WebSocket receives a message, the runtime will recreate the
    Durable Object    // (run the `constructor`) and deliver the message to the
    appropriate handler.    this.ctx.acceptWebSocket(server);    return new
    Response(null, {      status: 101,      webSocket: client,    });  }  async
    webSocketMessage(ws, message) {    // Upon receiving a message from the
    client, reply with the same message,    // but will prefix the message with
    "[Durable Object]: " and return the    // total number of
    connections.    ws.send(`[Durable Object] message: ${message}, connections:
    ${this.ctx.getWebSockets().length}`);  }  async webSocketClose(ws, code,
    reason, wasClean) {    // If the client closes the connection, the runtime
    will invoke the webSocketClose() handler.    ws.close(code, "Durable Object
    is closing WebSocket");  }}

    ```
- title: Use the Alarms API · Cloudflare Durable Objects docs
  content: |-
    # Use the Alarms API · Cloudflare Durable Objects docs

    This example implements an `alarm()` handler that wakes the Durable Object once every 10 seconds to batch requests to a single Durable Object. The `alarm()` handler will delay processing until there is enough work in the queue.

    ```
    import { DurableObject } from 'cloudflare:workers';// Workerexport default {  async fetch(request, env) {    let id = env.BATCHER.idFromName("foo");    return await env.BATCHER.get(id).fetch(request);  },};const SECONDS = 10;// Durable Objectexport class Batcher extends DurableObject {  constructor(state, env) {    this.state = state;    this.storage = state.storage;    this.state.blockConcurrencyWhile(async () => {      let vals = await this.storage.list({ reverse: true, limit: 1 });      this.count = vals.size == 0 ? 0 : parseInt(vals.keys().next().value);    });  }  async fetch(request) {    this.count++;    // If there is no alarm currently set, set one for 10 seconds from now    // Any further POSTs in the next 10 seconds will be part of this batch.    let currentAlarm = await this.storage.getAlarm();    if (currentAlarm == null) {      this.storage.setAlarm(Date.now() + (1000 * SECONDS));    }    // Add the request to the batch.    await this.storage.put(this.count, await request.text());    return new Response(JSON.stringify({ queued: this.count }), {      headers: {        "content-type": "application/json;charset=UTF-8",      },    });  }  async alarm() {    let vals = await this.storage.list();    await fetch("http://example.com/some-upstream-service", {      method: "POST",      body: Array.from(vals.values()),    });    await this.storage.deleteAll();    this.count = 0;  }}
    ```

    The `alarm()` handler will be called once every 10 seconds. If an unexpected error terminates the Durable Object, the `alarm()` handler will be re-instantiated on another machine. Following a short delay, the `alarm()` handler will run from the beginning on the other machine.

    Finally, configure your `wrangler.toml` file to include a Durable Object [binding](about:/durable-objects/get-started/#5-configure-durable-object-bindings) and [migration](/durable-objects/reference/durable-objects-migrations/) based on the namespace and class name chosen previously.

    -   [wrangler.toml](#tab-panel-1417)
    -   [wrangler.json](#tab-panel-1418)

    ```
    name = "durable-object-alarm"[[durable_objects.bindings]]name = "BATCHER"class_name = "Batcher"[[migrations]]tag = "v1"new_classes = ["Batcher"]
    ```

    ## Thank you for helping improve Cloudflare's documentation!
- title: Testing with Durable Objects · Cloudflare Durable Objects docs
  content: >-
    # Testing with Durable Objects · Cloudflare Durable Objects docs


    ```

    import { unstable_dev } from "wrangler"import type { UnstableDevWorker }
    from "wrangler"import { describe, expect, it, beforeAll, afterAll } from
    "vitest"describe("Worker", () => {  let worker:
    UnstableDevWorker  beforeAll(async () => {    worker = await
    unstable_dev("src/index.ts", {      experimental: {
    disableExperimentalWarning: true },    });  });  afterAll(async () =>
    {    await worker.stop()  })  it("should deny request for short paths",
    async () => {    const cases = {      failures: ["/", "/foo", "/foo/",
    "/%2F"],    }    for (const path of cases.failures) {      const resp =
    await worker.fetch(`http://example.com${path}`)      if (resp)
    {        const text = await
    resp.text()        expect(text).toMatchInlineSnapshot('"path must be at
    least 5 characters"')      }    }  })  describe("durable object", () =>
    {    it("Should send text from a POST to a matching GET", async () =>
    {      const path = "/stuff1"      const url =
    `http://example.com${path}`      // The get request should wait for the post
    request to complete      const getResponsePromise =
    worker.fetch(url)      // The post request to the same path should receive a
    response that the text was consumed      const postResponse = await
    worker.fetch(url, { method: "POST", body: "Hello World 12345"
    })      expect(postResponse.status).toBe(200)      const postText = await
    postResponse.text()      expect(postText).toBe("The text was
    consumed!")      // The get request should now receive the text      const
    getResponse = await
    getResponsePromise      expect(getResponse.status).toBe(200)      const text
    = await getResponse.text()      expect(text).toBe("Hello World
    12345")    })    it("Shouldn't send text from a POST to a different GET",
    async () => {      const path1 = "/stuff1"      const path2 =
    "/stuff2"      const url = (p: string) => `http://example.com${p}`      //
    The get request should wait for the post request to complete      const
    getResponsePromise1 = worker.fetch(url(path1))      const
    getResponsePromise2 = worker.fetch(url(path2))      // The post request to
    the same path should receive a response that the text was
    consumed      const postResponse1 = await worker.fetch(url(path1), { method:
    "POST", body: "Hello World 12345"
    })      expect(postResponse1.status).toBe(200)      const postText1 = await
    postResponse1.text()      expect(postText1).toBe("The text was
    consumed!")      const postResponse2 = await worker.fetch(url(path2), {
    method: "POST", body: "Hello World 789"
    })      expect(postResponse2.status).toBe(200)      const postText2 = await
    postResponse2.text()      expect(postText2).toBe("The text was
    consumed!")      // The get request should now receive the text      const
    getResponse1 = await
    getResponsePromise1      expect(getResponse1.status).toBe(200)      const
    text1 = await getResponse1.text()      expect(text1).toBe("Hello World
    12345")      const getResponse2 = await
    getResponsePromise2      expect(getResponse2.status).toBe(200)      const
    text2 = await getResponse2.text()      expect(text2).toBe("Hello World
    789")    })    it("Should not send the same POST twice", async () =>
    {      const path = "/stuff1"      const url = (p: string) =>
    `http://example.com${p}`      // The get request should wait for the post
    request to complete      const getResponsePromise1 =
    worker.fetch(url(path))      // The post request to the same path should
    receive a response that the text was consumed      const postResponse1 =
    await worker.fetch(url(path), { method: "POST", body: "Hello World 12345"
    })      expect(postResponse1.status).toBe(200)      const postText1 = await
    postResponse1.text()      expect(postText1).toBe("The text was
    consumed!")      // The get request should now receive the text      const
    getResponse1 = await
    getResponsePromise1      expect(getResponse1.status).toBe(200)      const
    text1 = await getResponse1.text()      expect(text1).toBe("Hello World
    12345")      // The next get request should wait for the next post request
    to complete      const getResponsePromise2 = worker.fetch(url(path))      //
    Send a new POST with different text      const postResponse2 = await
    worker.fetch(url(path), { method: "POST", body: "Hello World 789"
    })      expect(postResponse2.status).toBe(200)      const postText2 = await
    postResponse2.text()      expect(postText2).toBe("The text was
    consumed!")      // The get request should receive the new text, not the old
    text      const getResponse2 = await
    getResponsePromise2      expect(getResponse2.status).toBe(200)      const
    text2 = await getResponse2.text()      expect(text2).toBe("Hello World
    789")    })  })})

    ```
- title: Tutorials · Cloudflare Durable Objects docs
  content: |-
    # Tutorials · Cloudflare Durable Objects docs

    View tutorials to help you get started with Durable Objects.

    ## Thank you for helping improve Cloudflare's documentation!
- title: Durable Objects - Use KV within Durable Objects · Cloudflare Durable
    Objects docs
  content: >-
    # Durable Objects - Use KV within Durable Objects · Cloudflare Durable
    Objects docs


    ## Use Workers KV from Durable Objects


    Read and write to/from Workers KV within a Durable Object


    The following Worker script shows you how to configure a Durable Object to
    read from and/or write to a [Workers KV
    namespace](/kv/concepts/how-kv-works/). This is useful when using a Durable
    Object to coordinate between multiple clients, and allows you to serialize
    writes to KV and/or broadcast a single read from KV to hundreds or thousands
    of clients connected to a single Durable Object [using
    WebSockets](/durable-objects/best-practices/websockets/).


    Prerequisites:


    -   A [KV namespace](/kv/api/) created via the Cloudflare dashboard or the
    [wrangler CLI](/workers/wrangler/install-and-update/).

    -   A [configured binding](/kv/concepts/kv-bindings/) for the `kv_namespace`
    in the Cloudflare dashboard or `wrangler.toml` file.

    -   A [Durable Object namespace
    binding](about:/workers/wrangler/configuration/#durable-objects).


    Configure your `wrangler.toml` file as follows:


    -   [wrangler.toml](#tab-panel-1445)

    -   [wrangler.json](#tab-panel-1446)


    ```

    name = "my-worker"kv_namespaces = [  { binding = "YOUR_KV_NAMESPACE", id =
    "<id_of_your_namespace>" }][durable_objects]bindings = [  { name =
    "YOUR_DO_CLASS", class_name = "YourDurableObject" }]

    ```


    ```

    import { DurableObject } from 'cloudflare:workers';interface Env
    {  YOUR_KV_NAMESPACE: KVNamespace;  YOUR_DO_CLASS:
    DurableObjectNamespace;}export default {  async fetch(req: Request, env:
    Env): Promise<Response> {    // Assume each Durable Object is mapped to a
    roomId in a query parameter    // In a production application, this will
    likely be a roomId defined by your application    // that you validate
    (and/or authenticate) first.    let url = new URL(req.url);    let
    roomIdParam = url.searchParams.get("roomId");    if (roomIdParam) {      //
    Create (or get) a Durable Object based on that roomId.      let
    durableObjectId = env.YOUR_DO_CLASS.idFromName(roomIdParam);      // Get a
    "stub" that allows you to call that Durable Object      let
    durableObjectStub = env.YOUR_DO_CLASS.get(durableObjectId);      // Pass the
    request to that Durable Object and await the response      // This invokes
    the constructor once on your Durable Object class (defined further
    down)      // on the first initialization, and the fetch method on each
    request.      //      // You could pass the original Request to the Durable
    Object's fetch method      // or a simpler URL with just the
    roomId.      let response = await
    durableObjectStub.fetch(`http://do/${roomId}`);      // This would return
    the value you read from KV *within* the Durable Object.      return
    response;    }  }}export class YourDurableObject extends DurableObject
    {  constructor(public state: DurableObjectState, env: Env) {    this.state =
    state;    // Ensure you pass your bindings and environmental variables
    into    // each Durable Object when it is initialized    this.env =
    env;  }  async fetch(request: Request) {    // Error handling elided for
    brevity.    // Write to KV    await
    this.env.YOUR_KV_NAMESPACE.put("some-key");    // Fetch from KV    let val =
    await this.env.YOUR_KV_NAMESPACE.get("some-other-key");    return
    Response.json(val);  }}

    ```


    ## Thank you for helping improve Cloudflare's documentation!
- title: Demos and architectures · Cloudflare Durable Objects docs
  content: |-
    # Demos and architectures · Cloudflare Durable Objects docs

    Learn how you can use a Durable Object within your existing application and architecture.

    ## Demos

    Explore the following demo applications for Durable Objects.

    -   [NBA Finals Polling and Predictor:](https://github.com/elizabethsiegle/nbafinals-cloudflare-ai-hono-durable-objects) This stateful polling application uses Cloudflare Workers AI, Cloudflare Pages, Cloudflare Durable Objects, and Hono to keep track of users' votes for different basketball teams and generates personal predictions for the series.
    -   [Cloudflare Workers Chat Demo:](https://github.com/cloudflare/workers-chat-demo) This is a demo app written on Cloudflare Workers utilizing Durable Objects to implement real-time chat with stored history.
    -   [Wildebeest:](https://github.com/cloudflare/wildebeest) Wildebeest is an ActivityPub and Mastodon-compatible server whose goal is to allow anyone to operate their Fediverse server and identity on their domain without needing to keep infrastructure, with minimal setup and maintenance, and running in minutes.
    -   [Multiplayer Doom Workers:](https://github.com/cloudflare/doom-workers) A WebAssembly Doom port with multiplayer support running on top of Cloudflare's global network using Workers, WebSockets, Pages, and Durable Objects.

    ## Reference architectures

    Explore the following reference architectures that use Durable Objects:

    -   [Optimizing and securing connected transportation systems](/reference-architecture/diagrams/iot/optimizing-and-securing-connected-transportation-systems/)
    -   [Fullstack applications](/reference-architecture/diagrams/serverless/fullstack-application/)
    -   [Control and data plane architectural pattern for Durable Objects](/reference-architecture/diagrams/storage/durable-object-control-data-plane-pattern/)

    ## Thank you for helping improve Cloudflare's documentation!
- title: Pricing · Cloudflare Durable Objects docs
  content: |-
    # Pricing · Cloudflare Durable Objects docs

    ## Billing metrics

    [Durable Objects](/durable-objects/) are only available on the [Workers Paid plan](about:/workers/platform/pricing/#workers).

    |  | Paid plan |
    | --- | --- |
    | Requests | 1 million, + $0.15/million  
    Includes HTTP requests, RPC sessions1, WebSocket messages2, and alarm invocations |
    | Duration3 | 400,000 GB-s, + $12.50/million GB-s4,5 |

    1 Each [RPC session](/workers/runtime-apis/rpc/lifecycle/) is billed as one request to your Durable Object. Every [RPC method call](/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/) on a [Durable Objects stub](/durable-objects/) is its own RPC session and therefore a single billed request.

    RPC method calls can return objects (stubs) extending [`RpcTarget`](about:/workers/runtime-apis/rpc/lifecycle/#lifetimes-memory-and-resource-management) and invoke calls on those stubs. Subsequent calls on the returned stub are part of the same RPC session and are not billed as separate requests. For example:

    ```
    let durableObjectStub = OBJECT_NAMESPACE.get(id); // retrieve Durable Object stubusing foo = await durableObjectStub.bar(); // billed as a requestawait foo.baz(); // treated as part of the same RPC session created by calling bar(), not billed as a requestawait durableObjectStub.cat(); // billed as a request
    ```

    2 A request is needed to create a WebSocket connection. There is no charge for outgoing WebSocket messages, nor for incoming [WebSocket protocol pings ↗](https://www.rfc-editor.org/rfc/rfc6455#section-5.5.2). For compute requests billing-only, a 20:1 ratio is applied to incoming WebSocket messages to factor in smaller messages for real-time communication. For example, 100 WebSocket incoming messages would be charged as 5 requests for billing purposes. The 20:1 ratio does not affect Durable Object metrics and analytics, which reflect actual usage.

    3 Application level auto-response messages handled by [`state.setWebSocketAutoResponse()`](/durable-objects/best-practices/websockets/) will not incur additional wall-clock time, and so they will not be charged.

    4 Duration is billed in wall-clock time as long as the Object is active, but is shared across all requests active on an Object at once. Once your Object finishes responding to all requests, it will stop incurring duration charges. Calling `accept()` on a WebSocket in an Object will incur duration charges for the entire time the WebSocket is connected. If you prefer, use [`state.acceptWebSocket()`](/durable-objects/best-practices/websockets/) instead, which will stop incurring duration charges once all event handlers finish running.

    5 Duration billing charges for the 128 MB of memory your Durable Object is allocated, regardless of actual usage. If your account creates many instances of a single Durable Object class, Durable Objects may run in the same isolate on the same physical machine and share the 128 MB of memory. These Durable Objects are still billed as if they are allocated a full 128 MB of memory.

    ## Durable Objects billing examples

    These examples exclude the costs for the Workers calling the Durable Objects. When modelling the costs of a Durable Object, note that:

    -   Inactive objects receiving no requests do not incur any duration charges.
    -   The [WebSocket Hibernation API](about:/durable-objects/best-practices/websockets/#websocket-hibernation-api) can dramatically reduce duration-related charges for Durable Objects communicating with clients over the WebSocket protocol, especially if messages are only transmitted occasionally at sparse intervals.

    ### Example 1

    This example represents a simple Durable Object used as a co-ordination service invoked via HTTP.

    -   A single Durable Object was called by a Worker 1.5 million times
    -   It is active for 1,000,000 seconds in the month

    In this scenario, the estimated monthly cost would be calculated as:

    **Requests**:

    -   (1.5 million requests - included 1 million requests) x $0.15 / 1,000,000 = $0.075

    **Compute Duration**:

    -   1,000,000 seconds \* 128 MB / 1 GB = 128,000 GB-s
    -   (128,000 GB-s - included 400,000 GB-s) x $12.50 / 1,000,000 = $0.00

    **Estimated total**: ~$0.075 (requests) + $0.00 (compute duration) + minimum $5/mo usage = $5.08 per month

    ### Example 2

    This example represents a moderately trafficked Durable Objects based application using WebSockets to broadcast game, chat or real-time user state across connected clients:

    -   100 Durable Objects have 50 WebSocket connections established to each of them.
    -   Clients send approximately one message a minute for eight active hours a day, every day of the month.

    In this scenario, the estimated monthly cost would be calculated as:

    **Requests**:

    -   50 WebSocket connections \* 100 Durable Objects to establish the WebSockets = 5,000 connections created each day \* 30 days = 150,000 WebSocket connection requests.
    -   50 messages per minute \* 100 Durable Objects \* 60 minutes \* 8 hours \* 30 days = 72,000,000 WebSocket message requests.
    -   150,000 + (72 million requests / 20 for WebSocket message billing ratio) = 3.75 million billing request.
    -   (3.75 million requests - included 1 million requests) x $0.15 / 1,000,000 = $0.41.

    **Compute Duration**:

    -   100 Durable Objects \* 60 seconds \* 60 minutes \* 8 hours \* 30 days = 86,400,000 seconds.
    -   86,400,000 seconds \* 128 MB / 1 GB = 11,059,200 GB-s.
    -   (11,059,200 GB-s - included 400,000 GB-s) x $12.50 / 1,000,000 = $133.24.

    **Estimated total**: $0.41 (requests) + $133.24 (compute duration) + minimum $5/mo usage = $138.65 per month.

    ### Example 3

    This example represents a horizontally scaled Durable Objects based application using WebSockets to communicate user-specific state to a single client connected to each Durable Object.

    -   100 Durable Objects each have a single WebSocket connection established to each of them.
    -   Clients sent one message every second of the month so that the Durable Objects were active for the entire month.

    In this scenario, the estimated monthly cost would be calculated as:

    **Requests**:

    -   100 WebSocket connection requests.
    -   1 message per second \* 100 connections \* 60 seconds \* 60 minutes \* 24 hours \* 30 days = 259,200,000 WebSocket message requests.
    -   100 + (259.2 million requests / 20 for WebSocket billing ratio) = 12,960,100 requests.
    -   (12.9 million requests - included 1 million requests) x $0.15 / 1,000,000 = $1.79.

    **Compute Duration**:

    -   100 Durable Objects \* 60 seconds \* 60 minutes \* 24 hours \* 30 days = 259,200,000 seconds
    -   259,200,000 seconds \* 128 MB / 1 GB = 33,177,600 GB-s
    -   (33,177,600 GB-s - included 400,000 GB-s) x $12.50 / 1,000,000 = $409.72

    **Estimated total**: $1.79 (requests) + $409.72 (compute duration) + minimum $5/mo usage = $416.51 per month

    ### Example 4

    This example represents a moderately trafficked Durable Objects based application using WebSocket Hibernation to broadcast game, chat or real-time user state across connected clients:

    -   100 Durable Objects each have 100 Hibernatable WebSocket connections established to each of them.
    -   Clients send one message per minute, and it takes 10ms to process a single message in the `webSocketMessage()` handler. Since each Durable Object handles 100 WebSockets, cumulatively each Durable Object will be actively executing JS for 1 second each minute (100 WebSockets \* 10ms).

    In this scenario, the estimated monthly cost would be calculated as:

    **Requests**:

    -   100 WebSocket connections \* 100 Durable Objects to establish the WebSockets = 10,000 initial WebSocket connection requests.
    -   100 messages per minute1 \* 100 Durable Objects \* 60 minutes \* 24 hours \* 30 days = 432,000,000 requests.
    -   10,000 + (432 million requests / 20 for WebSocket billing ratio) = 21,610,000 million requests.
    -   (21.6 million requests - included 1 million requests) x $0.15 / 1,000,000 = $3.09.

    **Compute Duration**:

    -   100 Durable Objects \* 1 second2 \* 60 minutes \* 24 hours \* 30 days = 4,320,000 seconds
    -   4,320,000 seconds \* 128 MB / 1 GB = 552,960 GB-s
    -   (552,960 GB-s - included 400,000 GB-s) x $12.50 / 1,000,000 = $1.91

    **Estimated total**: $3.09 (requests) + $1.91 (compute duration) + minimum $5/mo usage = $10.00 per month

    1 100 messages per minute comes from the fact that 100 clients connect to each DO, and each sends 1 message per minute.

    2 The example uses 1 second because each Durable Object is active for 1 second per minute. This can also be thought of as 432 million requests that each take 10 ms to execute (4,320,000 seconds).

    ## Storage API billing

    The Durable Objects [Storage API](/durable-objects/api/storage-api) is only accessible from within Durable Objects.

    Durable Objects do not have to use the Storage API, but if your code does call methods on `ctx.storage`, it will incur additional charges.

    Pricing depends on whether a Durable Object class has default, key-value storage backend or opt-in [SQLite storage backend](about:/durable-objects/best-practices/access-durable-objects-storage/#sqlite-storage-backend).

    ### Key-value storage backend

    |  | Workers Paid plan |
    | --- | --- |
    | Read request units1,2 | 1 million, + $0.20/million |
    | Write request units3 | 1 million, + $1.00/million |
    | Delete requests4 | 1 million, + $1.00/million |
    | Stored data5 | 1 GB, + $0.20/ GB-month |

    1 A request unit is defined as 4 KB of data read or written. A request that writes or reads more than 4 KB will consume multiple units, for example, a 9 KB write will consume 3 write request units.

    2 List operations are billed by read request units, based on the amount of data examined. For example, a list request that returns a combined 80 KB of keys and values will be billed 20 read request units. A list request that does not return anything is billed for 1 read request unit.

    3 Each `setAlarm` is billed as a single write request unit.

    4 Delete requests are unmetered. For example, deleting a 100 KB value will be charged one delete request.

    5 Durable Objects will be billed for stored data until the data is removed. Once the data is removed, the object will be cleaned up automatically by the system.

    Requests that hit the [Durable Objects in-memory cache](/durable-objects/reference/in-memory-state/) or that use the [multi-key versions of `get()`/`put()`/`delete()` methods](/durable-objects/api/storage-api/) are billed the same as if they were a normal, individual request for each key.

    ### SQLite storage backend

    For [Durable Objects classes with SQLite storage backend](about:/durable-objects/reference/durable-objects-migrations/#enable-sqlite-storage-backend-on-new-durable-object-class-migration) via `ctx.storage.sql` the following pricing is used instead:

    |  | Workers Paid plan |
    | --- | --- |
    | Rows reads 1,2 | First 25 billion / month included + $0.001 / million rows |
    | Rows written 1,2 | First 50 million / month included + $1.00 / million rows |
    | SQL Stored data | 5 GB-month, + $0.20/ GB-month |

    1 Rows read and rows written included limits and rates match D1, Cloudflare's serverless SQL database, [pricing](/d1/platform/pricing/).

    2 Key-value methods like `get()`, `put()`, `delete()`, or `list()` store and query data in a hidden SQLite table and are billed as rows read and rows written.

    3 Each `setAlarm` is billed as a single row written.

    ## Thank you for helping improve Cloudflare's documentation!
- title: Limits · Cloudflare Durable Objects docs
  content: |-
    # Limits · Cloudflare Durable Objects docs

    Durable Objects are only available on the [Workers Paid plan](about:/workers/platform/pricing/#workers). Durable Objects limits are the same as [Workers Limits](/workers/platform/limits/), as well as the following limits that are specific to Durable Objects:

    | Feature | Limit for class with key-value storage backend | Limit for class with SQLite storage backend 1 |
    | --- | --- | --- |
    | Number of Objects | Unlimited (within an account or of a given class) | Unlimited (within an account or of a given class) |
    | Maximum Durable Object namespaces | 500 (identical to the [script limit](/workers/platform/limits/)) | 500 (identical to the [script limit](/workers/platform/limits/)) |
    | Storage per account | 50 GB (can be raised by contacting Cloudflare) 2 | 50 GB (can be raised by contacting Cloudflare) 2 |
    | Storage per class | Unlimited | Unlimited |
    | Storage per Durable Object | Unlimited | 1 GB 3 |
    | Key size | 2 KiB (2048 bytes) | Key and value combined cannot exceed 2 MB |
    | Value size | 128 KiB (131072 bytes) | Key and value combined cannot exceed 2 MB |
    | WebSocket message size | 1 MiB (only for received messages) | 1 MiB (only for received messages) |
    | CPU per request | 30s (including WebSocket messages) 4 | 30s (including WebSocket messages) 4 |

    For Durable Object classes with [SQLite storage backend](about:/durable-objects/best-practices/access-durable-objects-storage/#sqlite-storage-backend) these SQL limits apply:

    | SQL | Limit |
    | --- | --- |
    | Maximum number of columns per table | 100 |
    | Maximum number of rows per table | Unlimited (excluding per-object storage limits) |
    | Maximum string, `BLOB` or table row size | 2 MB |
    | Maximum SQL statement length | 100 KB |
    | Maximum bound parameters per query | 100 |
    | Maximum arguments per SQL function | 32 |
    | Maximum characters (bytes) in a `LIKE` or `GLOB` pattern | 50 bytes |

    ## How much work can a single Durable Object do?

    Durable Objects can scale horizontally across many Durable Objects. Each individual Object is inherently single-threaded.

    -   An individual Object has a soft limit of 1,000 requests per second. You can have an unlimited number of individual objects per namespace.
    -   A simple [storage](/durable-objects/api/storage-api/) `get()` on a small value that directly returns the response may realize a higher request throughput compared to a Durable Object that (for example) serializes and/or deserializes large JSON values.
    -   Similarly, a Durable Object that performs multiple `list()` operations may be more limited in terms of request throughput.

    A Durable Object that receives too many requests will, after attempting to queue them, return an [overloaded](about:/durable-objects/observability/troubleshooting/#durable-object-is-overloaded) error to the caller.

    ## How many Durable Objects can I create?

    Durable Objects are designed such that the number of individual objects in the system do not need to be limited, and can scale horizontally.

    -   You can create and run as many separate Durable Objects as you want within a given Durable Object namespace.
    -   The main limit to your usage of Durable Objects is the total storage limit per account.
    -   If you need more storage, contact your account team or complete the [Limit Increase Request Form ↗](https://forms.gle/ukpeZVLWLnKeixDu7) and we will contact you with next steps.

    ## Thank you for helping improve Cloudflare's documentation!
- title: Known issues · Cloudflare Durable Objects docs
  content: |-
    # Known issues · Cloudflare Durable Objects docs

    Durable Objects is generally available. However, there are some known issues.

    ## Global uniqueness

    Global uniqueness guarantees there is only a single instance of a Durable Object class with a given ID running at once, across the world.

    Uniqueness is enforced upon starting a new event (such as receiving an HTTP request), and upon accessing storage.

    After an event is received, if the event takes some time to execute and does not ever access its durable storage, then it is possible that the Durable Object may no longer be current, and some other instance of the same Durable Object ID will have been created elsewhere. If the event accesses storage at this point, it will receive an [exception](/durable-objects/observability/troubleshooting/). If the event completes without ever accessing storage, it may not ever realize that the Durable Object was no longer current.

    A Durable Object may be replaced in the event of a network partition or a software update (including either an update of the Durable Object's class code, or of the Workers system itself). Enabling `wrangler tail` or [Cloudflare dashboard ↗](https://dash.cloudflare.com/) logs requires a software update.

    ## Code updates

    Code changes for Workers and Durable Objects are released globally in an eventually consistent manner. Because each Durable Object is globally unique, the situation can arise that a request arrives to the latest version of your Worker (running in one part of the world), which then calls to a unique Durable Object running the previous version of your code for a short period of time (typically seconds to minutes). If you create a [gradual deployment](/workers/configuration/versions-and-deployments/gradual-deployments/), this period of time is determined by how long your live deployment is configured to use more than one version.

    For this reason, it is best practice to ensure that API changes between your Workers and Durable Objects are forward and backward compatible across code updates.

    [`wrangler tail`](about:/workers/wrangler/commands/#tail) logs from requests that are upgraded to WebSockets are delayed until the WebSocket is closed. `wrangler tail` should not be connected to a Worker that you expect will receive heavy volumes of traffic.

    The Workers editor in the [Cloudflare dashboard ↗](https://dash.cloudflare.com/) allows you to interactively edit and preview your Worker and Durable Objects. In the editor, Durable Objects can only be talked to by a preview request if the Worker being previewed both exports the Durable Object class and binds to it. Durable Objects exported by other Workers cannot be talked to in the editor preview.

    [`wrangler dev`](about:/workers/wrangler/commands/#dev) has read access to Durable Object storage, but writes will be kept in memory and will not affect persistent data. However, if you specify the `script_name` explicitly in the [Durable Object binding](/workers/runtime-apis/bindings/), then writes will affect persistent data. Wrangler will emit a warning in that case.

    ## Thank you for helping improve Cloudflare's documentation!
- title: In-memory state in a Durable Object · Cloudflare Durable Objects docs
  content: >-
    # In-memory state in a Durable Object · Cloudflare Durable Objects docs


    In-memory state means that each Durable Object has one active instance at
    any particular time. All requests sent to that Durable Object are handled by
    that same instance. You can store some state in memory.


    Variables in a Durable Object will maintain state as long as your Durable
    Object is not evicted from memory.


    A common pattern is to initialize a Durable Object from [persistent
    storage](/durable-objects/api/storage-api/) and set instance variables the
    first time it is accessed. Since future accesses are routed to the same
    Durable Object, it is then possible to return any initialized values without
    making further calls to persistent storage.


    ```

    export class Counter {  constructor(state, env) {    this.state =
    state;    // `blockConcurrencyWhile()` ensures no requests are delivered
    until    // initialization
    completes.    this.state.blockConcurrencyWhile(async () => {      let stored
    = await this.state.storage.get("value");      // After initialization,
    future reads do not need to access storage.      this.value = stored ||
    0;    });  }  // Handle HTTP requests from clients.  async fetch(request)
    {    // use this.value rather than storage  }}

    ```


    A given instance of a Durable Object may share global memory with other
    instances defined in the same Worker code.


    In the example above, using a global variable `value` instead of the
    instance variable `this.value` would be incorrect. Two different instances
    of `Counter` will each have their own separate memory for `this.value`, but
    might share memory for the global variable `value`, leading to unexpected
    results. Because of this, it is best to avoid global variables.


    ## Thank you for helping improve Cloudflare's documentation!
- title: Durable Objects migrations · Cloudflare Durable Objects docs
  content: >-
    # Durable Objects migrations · Cloudflare Durable Objects docs


    A migration is a mapping process from a class name to a runtime state.


    You must initiate a migration process when you:


    -   Create a new Durable Object class.

    -   Rename a Durable Object class.

    -   Delete a Durable Object class.

    -   Transfer an existing Durable Objects class.


    This process informs the Workers runtime of the changes and provides it with
    instructions on how to deal with those changes.


    The most common migration performed is a new class migration, which informs
    the runtime that a new Durable Object class is being uploaded.


    Migrations can also be used for transferring stored data between two Durable
    Object classes:


    -   Rename migrations are used to transfer stored Durable Objects between
    two Durable Object classes in the same Worker code file.

    -   Transfer migrations are used to transfer stored Durable Objects between
    two Durable Object classes in different Worker code files.


    The destination class (the class that stored Durable Objects are being
    transferred to) for a rename or transfer migration must be exported by the
    deployed Worker.


    Migrations can also be used to delete a Durable Object class and its stored
    Durable Objects.


    ### Durable Object migrations in `wrangler.toml`


    Migrations are performed through the `[[migrations]]` configurations key in
    your `wrangler.toml` file.


    Migrations require a migration tag, which is defined by the `tag` property
    in each migration entry.


    Migration tags are treated like unique names and are used to determine which
    migrations have already been applied. Once a given Worker code has a
    migration tag set on it, all future Worker code deployments must include a
    migration tag.


    The migration list is an ordered array of tables, specified as a top-level
    key in your `wrangler.toml` file. The migration list is inherited by all
    environments and cannot be overridden by a specific environment.


    All migrations are applied at deployment. Each migration can only be applied
    once per [environment](/durable-objects/reference/environments/).


    To illustrate an example migrations workflow, the `DurableObjectExample`
    class can be initially defined with:


    -   [wrangler.toml](#tab-panel-1549)

    -   [wrangler.json](#tab-panel-1550)


    ```

    [[migrations]]tag = "v1" # Should be unique for each entrynew_classes =
    ["DurableObjectExample"] # Array of new classes

    ```


    Each migration in the list can have multiple directives, and multiple
    migrations can be specified as your project grows in complexity. For
    example, you may want to rename the `DurableObjectExample` class to
    `UpdatedName` and delete an outdated `DeprecatedClass` entirely.


    -   [wrangler.toml](#tab-panel-1553)

    -   [wrangler.json](#tab-panel-1554)


    ```

    [[migrations]]tag = "v1" # Should be unique for each entrynew_classes =
    ["DurableObjectExample"] # Array of new classes[[migrations]]tag =
    "v2"renamed_classes = [{from = "DurableObjectExample", to = "UpdatedName" }]
    # Array of rename directivesdeleted_classes = ["DeprecatedClass"] # Array of
    deleted class names

    ```


    ### Enable SQLite storage backend on new Durable Object class migration


    To allow a new Durable Object class to use a SQLite storage backend, use
    `new_sqlite_classes` on the migration in your Worker's `wrangler.toml` file:


    -   [wrangler.toml](#tab-panel-1551)

    -   [wrangler.json](#tab-panel-1552)


    ```

    [[migrations]]tag = "v1" # Should be unique for each entrynew_sqlite_classes
    = ["MyDurableObject"] # Array of new classes

    ```


    You cannot enable a SQLite storage backend on an existing, deployed Durable
    Object class, so setting `new_sqlite_classes` on later migrations will fail
    with an error. Automatic migration of deployed classes from their key-value
    storage backend to SQLite storage backend will be available in the future.


    ## Thank you for helping improve Cloudflare's documentation!
- title: Data security · Cloudflare Durable Objects docs
  content: >-
    # Data security · Cloudflare Durable Objects docs


    This page details the data security properties of Durable Objects,
    including:


    -   Encryption-at-rest (EAR).

    -   Encryption-in-transit (EIT).

    -   Cloudflare's compliance certifications.


    ## Encryption at Rest


    All Durable Object data, including metadata, is encrypted at rest.
    Encryption and decryption are automatic, do not require user configuration
    to enable, and do not impact the effective performance of Durable Objects.


    Encryption keys are managed by Cloudflare and securely stored in the same
    key management systems we use for managing encrypted data across Cloudflare
    internally.


    Encryption at rest is implemented using the Linux Unified Key Setup (LUKS)
    disk encryption specification and [AES-256
    ↗](https://www.cloudflare.com/learning/ssl/what-is-encryption/), a widely
    tested, highly performant and industry-standard encryption algorithm.


    ## Encryption in Transit


    Data transfer between a Cloudflare Worker, and/or between nodes within the
    Cloudflare network and Durable Objects is secured using the same [Transport
    Layer Security
    ↗](https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/)
    (TLS/SSL).


    API access via the HTTP API or using the
    [wrangler](/workers/wrangler/install-and-update/) command-line interface is
    also over TLS/SSL (HTTPS).


    ## Compliance


    To learn more about Cloudflare's adherence to industry-standard security
    compliance certifications, visit the Cloudflare [Trust Hub
    ↗](https://www.cloudflare.com/trust-hub/compliance-resources/).


    ## Thank you for helping improve Cloudflare's documentation!
- title: Data location · Cloudflare Durable Objects docs
  content: |-
    # Data location · Cloudflare Durable Objects docs

    ## Restrict Durable Objects to a jurisdiction

    Jurisdictions are used to create Durable Objects that only run and store data within a region to comply with local regulations such as the [GDPR ↗](https://gdpr-info.eu/) or [FedRAMP ↗](https://blog.cloudflare.com/cloudflare-achieves-fedramp-authorization/).

    Workers may still access Durable Objects constrained to a jurisdiction from anywhere in the world. The jurisdiction constraint only controls where the Durable Object itself runs and persists data. Consider using [Regional Services](/data-localization/regional-services/) to control the regions from which Cloudflare responds to requests.

    Durable Objects can be restricted to a specific jurisdiction either by creating a [`DurableObjectNamespace`](/durable-objects/api/namespace/) restricted to a jurisdiction, or by creating an individual [`DurableObjectId`](/durable-objects/api/id) restricted to a jurisdiction:

    ```
    const euSubnamespace = env.MY_DURABLE_OBJECT.jurisdiction("eu");const euId = euSubnamespace.newUniqueId();// orconst euId = env.MY_DURABLE_OBJECT.newUniqueId({ jurisdiction: "eu" });
    ```

    Methods on a [`DurableObjectNamespace`](/durable-objects/api/namespace/) that take a [`DurableObjectId`](/durable-objects/api/id) as a parameter will throw an exception if the parameter is associated with a different jurisdiction. To achieve this, a [`DurableObjectId`](/durable-objects/api/id) encodes its jurisdiction. As a consequence, it is possible to have the same name represent different IDs in different jurisdictions.

    ```
    const euId1 = env.MY_DURABLE_OBJECT.idFromName("my-name");const euId2 = env.MY_DURABLE_OBJECT.jurisdiction("eu").idFromName("my-name");console.assert(!euId1.equal(euId2), "This should always be true");
    ```

    Methods on a [`DurableObjectNamespace`](/durable-objects/api/namespace/) that take a [`DurableObjectId`](/durable-objects/api/id) as a parameter will throw an exception if the parameter is associated with a different jurisdiction. However, these methods will not throw an exception if the [`DurableObjectNamespace`](/durable-objects/api/namespace/) is not associated with a jurisdiction. The common case is that any valid [`DurableObjectId`](/durable-objects/api/id) can be used in the top-level namespace's methods.

    ```
    const euSubnamespace = env.MY_DURABLE_OBJECT.jurisdiction("eu");const euId = euSubnamespace.idFromName(name);const stub = env.MY_DURABLE_OBJECT.get(euId);
    ```

    ### Supported locations

    | Parameter | Location |
    | --- | --- |
    | eu | The European Union |
    | fedramp | FedRAMP-compliant data centers |

    ## Provide a location hint

    Durable Objects, as with any stateful API, will often add response latency as requests must be forwarded to the data center where the Durable Object, or state, is located.

    Durable Objects do not currently change locations after they are created1. By default, a Durable Object is instantiated in a data center close to where the initial `get()` request is made. This may not be in the same data center that the `get()` request is made from, but in most cases, it will be in close proximity.

    Location hints are the mechanism provided to specify the location that a Durable Object should be located regardless of where the initial `get()` request comes from.

    To manually create Durable Objects in another location, provide an optional `locationHint` parameter to `get()`. Only the first call to `get()` for a particular Object will respect the hint.

    ```
    let durableObjectStub = OBJECT_NAMESPACE.get(id, { locationHint: "enam" });
    ```

    ### Supported locations

    | Parameter | Location |
    | --- | --- |
    | wnam | Western North America |
    | enam | Eastern North America |
    | sam | South America 2 |
    | weur | Western Europe |
    | eeur | Eastern Europe |
    | apac | Asia-Pacific |
    | oc | Oceania |
    | afr | Africa 2 |
    | me | Middle East 2 |

    1 Dynamic relocation of existing Durable Objects is planned for the future.

    2 Durable Objects currently do not spawn in this location. Instead, the Durable Object will spawn in a nearby location which does support Durable Objects. For example, Durable Objects hinted to South America spawn in Eastern North America instead.

    ## Thank you for helping improve Cloudflare's documentation!
- title: Environments · Cloudflare Durable Objects docs
  content: >-
    # Environments · Cloudflare Durable Objects docs


    [Wrangler](/workers/wrangler/install-and-update/) allows you to deploy the
    same Worker application with different configuration for each
    [environment](/workers/wrangler/environments/).


    If you are using Wrangler environments, you must specify any [Durable Object
    bindings](/workers/runtime-apis/bindings/) you wish to use on a
    per-environment basis.


    Durable Object bindings are not inherited. For example, you can define an
    environment named `staging` as below:


    -   [wrangler.toml](#tab-panel-1567)

    -   [wrangler.json](#tab-panel-1568)


    ```

    [env.staging]durable_objects.bindings = [  {name = "EXAMPLE_CLASS",
    class_name = "DurableObjectExample"}]

    ```


    Because Wrangler appends the [environment
    name](/workers/wrangler/environments/) to the top-level name when
    publishing, for a Worker named `worker-name` the above example is equivalent
    to:


    -   [wrangler.toml](#tab-panel-1569)

    -   [wrangler.json](#tab-panel-1570)


    ```

    [env.staging]durable_objects.bindings = [  {name = "EXAMPLE_CLASS",
    class_name = "DurableObjectExample", script_name = "worker-name-staging"}]

    ```


    `"EXAMPLE_CLASS"` in the staging environment is bound to a different Worker
    code name compared to the top-level `"EXAMPLE_CLASS"` binding, and will
    therefore access different Durable Objects with different persistent
    storage.


    If you want an environment-specific binding that accesses the same Objects
    as the top-level binding, specify the top-level Worker code name explicitly
    using `script_name`:


    -   [wrangler.toml](#tab-panel-1571)

    -   [wrangler.json](#tab-panel-1572)


    ```

    [env.another]durable_objects.bindings = [  {name = "EXAMPLE_CLASS",
    class_name = "DurableObjectExample", script_name = "worker-name"}]

    ```


    ## Thank you for helping improve Cloudflare's documentation!
- title: Glossary · Cloudflare Durable Objects docs
  content: |-
    # Glossary · Cloudflare Durable Objects docs

    Review the definitions for terms used across Cloudflare's Durable Objects documentation.

    | Term | Definition |
    | --- | --- |
    | alarm | 
    A Durable Object alarm is a mechanism that allows you to schedule the Durable Object to be woken up at a time in the future.

     |
    | Durable Object | 

    A Durable Object is an individual instance of a Durable Object class. A Durable Object is globally unique (referenced by ID), provides a global point of coordination for all methods/requests sent to it, and has private, persistent storage that is not shared with other Durable Objects within a namespace.

     |
    | Durable Object class | 

    The JavaScript class that defines the methods (RPC) and handlers (`fetch`, `alarm`) as part of your Durable Object, and/or an optional `constructor`. All Durable Objects within a single namespace share the same class definition.

     |
    | Durable Objects | 

    The product name, or the collective noun referring to more than one Durable Object.

     |
    | event context | 

    The duration of time that a Durable Object is processing an event, such as a remote procedure call. [Compute duration charges](https://developers.cloudflare.com/durable-objects/platform/pricing) are incurred for the duration of the event context.

     |
    | instance | 

    See "Durable Object".

     |
    | KV API | 

    API methods part of Storage API that support persisting key-value data.

     |
    | migration | 

    A Durable Object migration is a mapping process from a class name to a runtime state. Initiate a Durable Object migration when you need to:

    -   Create a new Durable Object class.
    -   Rename a Durable Object class.
    -   Delete a Durable Object class.
    -   Transfer an existing Durable Objects class.

     |
    | namespace | 

    A container for a collection of Durable Objects that all share the same Durable Object (class) definition. A single namespace can have (tens of) millions of Durable Objects. Metrics are scoped per namespace.

     |
    | SQL API | 

    API methods part of Storage API that support SQL querying.

     |
    | Storage API | 

    The transactional and strongly consistent (serializable) [Storage API](https://developers.cloudflare.com/durable-objects/api/storage-api/) for persisting data within each Durable Object. State stored within a unique Durable Object is "private" to that Durable Object, and not accessible from other Durable Objects.

    Storage API includes key-value (KV) API, SQL API, and point-in-time-recovery (PITR) API.

    -   Durable Object classes with the key-value storage backend can use KV API.
    -   Durable Object classes with the SQLite storage backend can use KV API, SQL API, and PITR API.

     |
    | Storage Backend | 

    By default, a Durable Object class can use Storage API that leverages a key-value storage backend. New Durable Object classes can opt-in to using a [SQLite storage backend](https://developers.cloudflare.com/durable-objects/best-practices/access-durable-objects-storage/#sqlite-storage-backend).

     |
    | stub | 

    An object that refers to a unique Durable Object within a namespace and allows you to call into that Durable Object via RPC methods or the `fetch` API. For example, `let stub = env.MY_DURABLE_OBJECT.get(id)`

     |

    ## Thank you for helping improve Cloudflare's documentation!
- title: Changelog · Cloudflare Durable Objects docs
  content: |-
    # Changelog · Cloudflare Durable Objects docs

    ## 2024-10-07

    ## 2024-09-27

    **Alarms disabled in (beta) SQLite-backed Durable Object classes**

    An issue was identified with [alarms](https://developers.cloudflare.com/durable-objects/api/alarms/) in [beta Durable Object classes with a SQLite storage backend](https://developers.cloudflare.com/durable-objects/best-practices/access-durable-objects-storage/#sqlite-storage-backend). Alarms have been temporarily disabled for only SQLite-backed Durable Objects while a fix is implemented. Alarms in Durable Objects with default, key-value storage backend are unaffected and continue to operate.

    ## 2024-09-26

    **(Beta) SQLite storage backend & SQL API available on new Durable Object classes**

    The new beta version of Durable Objects is available where each Durable Object has a private, embedded SQLite database. When deploying a new Durable Object class, users can [opt-in to a SQLite storage backend](https://developers.cloudflare.com/durable-objects/best-practices/access-durable-objects-storage/#sqlite-storage-backend) in order to access new [SQL API](https://developers.cloudflare.com/durable-objects/api/sql-storage/#exec) and [point-in-time-recovery API](https://developers.cloudflare.com/durable-objects/api/sql-storage/#point-in-time-recovery), part of Durable Objects Storage API.

    You cannot enable a SQLite storage backend on an existing, deployed Durable Object class. Automatic migration of deployed classes from their key-value storage backend to SQLite storage backend will be available in the future.

    During the initial beta, Storage API billing is not enabled for Durable Object classes using SQLite storage backend. SQLite-backed Durable Objects will incur [charges for requests and duration](https://developers.cloudflare.com/durable-objects/platform/pricing/#billing-metrics). We plan to enable Storage API billing for Durable Objects using SQLite storage backend in the first half of 2025 after advance notice with the following [pricing](https://developers.cloudflare.com/durable-objects/platform/pricing/#sqlite-storage-backend).

    ## 2024-09-07

    **New error message for overloaded Durable Objects**

    Introduced a new overloaded error message for Durable Objects: "Durable Object is overloaded. Too many requests for the same object within a 10 second window."

    This error message does not replace other types of overload messages that you may encounter for your Durable Object, and is only returned at more extreme levels of overload.

    ## 2024-06-24

    [Exceptions](https://developers.cloudflare.com/durable-objects/best-practices/error-handling) thrown from Durable Object internal operations and tunneled to the caller may now be populated with a `.retryable: true` property if the exception was likely due to a transient failure, or populated with an `.overloaded: true` property if the exception was due to [overload](https://developers.cloudflare.com/durable-objects/observability/troubleshooting/#durable-object-is-overloaded).

    ## 2024-04-03

    **Durable Objects support for Oceania region**

    Durable Objects can reside in Oceania, lowering Durable Objects request latency for eyeball Workers in Oceania locations.

    Refer to [Durable Objects](https://developers.cloudflare.com/durable-objects/reference/data-location/#provide-a-location-hint) to provide location hints to objects.

    ## 2024-04-01

    **Billing reduction for WebSocket messages**

    Durable Objects [request billing](https://developers.cloudflare.com/durable-objects/platform/pricing/#billing-metrics) applies a 20:1 ratio for incoming WebSocket messages. For example, 1 million Websocket received messages across connections would be charged as 50,000 Durable Objects requests.

    This is a billing-only calculation and does not impact Durable Objects [metrics and analytics](https://developers.cloudflare.com/durable-objects/observability/graphql-analytics/).

    ## Thank you for helping improve Cloudflare's documentation!
- title: Get started · Cloudflare Durable Objects docs
  content: |-
    # Get started · Cloudflare Durable Objects docs

    1.  [Products](/products/)

    3.  [Durable Objects](/durable-objects/)
    4.  [Get started](/durable-objects/get-started/)

    -   [Walkthrough](/durable-objects/get-started/walkthrough/)
    -   [Tutorial with SQL API](/durable-objects/get-started/tutorial-with-sql-api/)
    -   [Video series](/durable-objects/get-started/video-series/)

    ## Was this helpful?

    Yes No

    ## What did you like?

    Accurate

    Easy to understand

    Solved my problem

    Helped me decide to use the product

    Other

    ## What went wrong?

    Hard to understand

    Incorrect information

    Missing the information

    Other

    ## Thank you for helping improve Cloudflare's documentation!

    [Cloudflare Dashboard](https://dash.cloudflare.com/?to=/:account/workers)[Discord](https://discord.cloudflare.com/)[Community](https://community.cloudflare.com/)[Learning Center](https://www.cloudflare.com/learning/)[Support Portal](/support/contacting-cloudflare-support/)

    Cookie Settings
- title: Best practices · Cloudflare Durable Objects docs
  content: |-
    # Best practices · Cloudflare Durable Objects docs

    1.  [Products](/products/)

    3.  [Durable Objects](/durable-objects/)
    4.  [Best practices](/durable-objects/best-practices/)

    -   [Invoking methods](/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/)
    -   [Access Durable Objects Storage](/durable-objects/best-practices/access-durable-objects-storage/)
    -   [Error handling](/durable-objects/best-practices/error-handling/)
    -   [Using WebSockets](/durable-objects/best-practices/websockets/)

    ## Was this helpful?

    Yes No

    ## What did you like?

    Accurate

    Easy to understand

    Solved my problem

    Helped me decide to use the product

    Other

    ## What went wrong?

    Hard to understand

    Incorrect information

    Missing the information

    Other

    ## Thank you for helping improve Cloudflare's documentation!

    [Cloudflare Dashboard](https://dash.cloudflare.com/?to=/:account/workers)[Discord](https://discord.cloudflare.com/)[Community](https://community.cloudflare.com/)[Learning Center](https://www.cloudflare.com/learning/)[Support Portal](/support/contacting-cloudflare-support/)

    Cookie Settings
- title: Examples · Cloudflare Durable Objects docs
  content: |-
    # Examples · Cloudflare Durable Objects docs

    Explore the following examples for Durable Objects.

    ## Thank you for helping improve Cloudflare's documentation!
- title: Workers Binding API · Cloudflare Durable Objects docs
  content: |-
    # Workers Binding API · Cloudflare Durable Objects docs

    1.  [Products](/products/)

    3.  [Durable Objects](/durable-objects/)
    4.  [Workers Binding API](/durable-objects/api/)

    -   [Durable Object Namespace](/durable-objects/api/namespace/)
    -   [Durable Object ID](/durable-objects/api/id/)
    -   [Durable Object Stub](/durable-objects/api/stub/)
    -   [Durable Object State](/durable-objects/api/state/)
    -   [Durable Object Storage](/durable-objects/api/storage-api/)
    -   [SQL Storage](/durable-objects/api/sql-storage/)
    -   [Alarms](/durable-objects/api/alarms/)
    -   [WebGPU](/durable-objects/api/webgpu/)
    -   [Rust API](https://github.com/cloudflare/workers-rs?tab=readme-ov-file#durable-objects)

    ## Was this helpful?

    Yes No

    ## What did you like?

    Accurate

    Easy to understand

    Solved my problem

    Helped me decide to use the product

    Other

    ## What went wrong?

    Hard to understand

    Incorrect information

    Missing the information

    Other

    ## Thank you for helping improve Cloudflare's documentation!

    [Cloudflare Dashboard](https://dash.cloudflare.com/?to=/:account/workers)[Discord](https://discord.cloudflare.com/)[Community](https://community.cloudflare.com/)[Learning Center](https://www.cloudflare.com/learning/)[Support Portal](/support/contacting-cloudflare-support/)

    Cookie Settings
- title: Observability · Cloudflare Durable Objects docs
  content: |-
    # Observability · Cloudflare Durable Objects docs

    1.  [Products](/products/)

    3.  [Durable Objects](/durable-objects/)
    4.  [Observability](/durable-objects/observability/)

    -   [Troubleshooting](/durable-objects/observability/troubleshooting/)
    -   [Metrics and GraphQL analytics](/durable-objects/observability/graphql-analytics/)

    ## Was this helpful?

    Yes No

    ## What did you like?

    Accurate

    Easy to understand

    Solved my problem

    Helped me decide to use the product

    Other

    ## What went wrong?

    Hard to understand

    Incorrect information

    Missing the information

    Other

    ## Thank you for helping improve Cloudflare's documentation!

    [Cloudflare Dashboard](https://dash.cloudflare.com/?to=/:account/workers)[Discord](https://discord.cloudflare.com/)[Community](https://community.cloudflare.com/)[Learning Center](https://www.cloudflare.com/learning/)[Support Portal](/support/contacting-cloudflare-support/)

    Cookie Settings
- title: Platform · Cloudflare Durable Objects docs
  content: |-
    # Platform · Cloudflare Durable Objects docs

    1.  [Products](/products/)

    3.  [Durable Objects](/durable-objects/)
    4.  [Platform](/durable-objects/platform/)

    -   [Known issues](/durable-objects/platform/known-issues/)
    -   [Pricing](/durable-objects/platform/pricing/)
    -   [Limits](/durable-objects/platform/limits/)
    -   [Choose a data or storage product](/workers/platform/storage-options/)

    ## Was this helpful?

    Yes No

    ## What did you like?

    Accurate

    Easy to understand

    Solved my problem

    Helped me decide to use the product

    Other

    ## What went wrong?

    Hard to understand

    Incorrect information

    Missing the information

    Other

    ## Thank you for helping improve Cloudflare's documentation!

    [Cloudflare Dashboard](https://dash.cloudflare.com/?to=/:account/workers)[Discord](https://discord.cloudflare.com/)[Community](https://community.cloudflare.com/)[Learning Center](https://www.cloudflare.com/learning/)[Support Portal](/support/contacting-cloudflare-support/)

    Cookie Settings
- title: Build a seat booking app with SQLite in Durable Objects · Cloudflare
    Durable Objects docs
  content: |-
    # Build a seat booking app with SQLite in Durable Objects · Cloudflare Durable Objects docs

    In this tutorial, you will learn how to build a seat reservation app using Durable Objects. This app will allow users to book a seat for a flight. The app will be written in TypeScript and will use the new [SQLite storage backend in Durable Object](about:/durable-objects/best-practices/access-durable-objects-storage/#sqlite-storage-backend) to store the data.

    Using Durable Objects, you can write reusable code that can handle coordination and state management for multiple clients. Moreover, writing data to SQLite in Durable Objects is synchronous and uses local disks, therefore all queries are executed with great performance. You can learn more about SQLite storage in Durable Objects in the [SQLite in Durable Objects blog post ↗](https://blog.cloudflare.com/sqlite-in-durable-objects).

    The application will function as follows:

    -   A user navigates to the application with a flight number passed as a query parameter.
    -   The application will create a new Durable Object for the flight number, if it does not already exist.
    -   If the Durable Object already exists, the application will retrieve the seats information from the SQLite database.
    -   If the Durable Object does not exist, the application will create a new Durable Object and initialize the SQLite database with the seats information. For the purpose of this tutorial, the seats information is hard-coded in the application.
    -   When a user selects a seat, the application asks for their name. The application will then reserve the seat and store the name in the SQLite database.
    -   The application also broadcasts any changes to the seats to all clients.

    Let's get started!

    ## Prerequisites

    1.  Sign up for a [Cloudflare account ↗](https://dash.cloudflare.com/sign-up/workers-and-pages).
    2.  Install [`Node.js` ↗](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).

    Node.js version manager

    Use a Node version manager like [Volta ↗](https://volta.sh/) or [nvm ↗](https://github.com/nvm-sh/nvm) to avoid permission issues and change Node.js versions. [Wrangler](/workers/wrangler/install-and-update/), discussed later in this guide, requires a Node version of `16.17.0` or later.

    ## 1\. Create a new project

    Create a new Worker project to create and deploy your app.

    1.  Create a Worker named `seat-booking` by running:
        
        -   [npm](#tab-panel-1585)
        -   [yarn](#tab-panel-1586)
        -   [pnpm](#tab-panel-1587)
        
        ```
        npm create cloudflare@latest -- seat-booking
        ```
        
        For setup, select the following options:
        
        -   For _What would you like to start with?_, choose `Hello World example`.
        -   For _Which template would you like to use?_, choose `Hello World Worker Using Durable Objects`.
        -   For _Which language do you want to use?_, choose `TypeScript`.
        -   For _Do you want to use git for version control?_, choose `Yes`.
        -   For _Do you want to deploy your application?_, choose `No` (we will be making some changes before deploying).
    2.  Change into your new project directory to start developing:
        

    ## 2\. Create the frontend

    The frontend of the application is a simple HTML page that allows users to select a seat and enter their name. The application uses [Workers Static Assets](/workers/static-assets/binding/) to serve the frontend.

    1.  Create a new directory named `public` in the project root.
        
    2.  Create a new file named `index.html` in the `public` directory.
        
    3.  Add the following HTML code to the `index.html` file:
        

    public/index.html

    ```
    <!doctype html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <title>Flight Seat Booking</title>    <style>      body {        font-family: Arial, sans-serif;        display: flex;        justify-content: center;        align-items: center;        height: 100vh;        margin: 0;        background-color: #f0f0f0;      }      .booking-container {        background-color: white;        padding: 20px;        border-radius: 8px;        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);      }      .seat-grid {        display: grid;        grid-template-columns: repeat(7, 1fr);        gap: 10px;        margin-top: 20px;      }      .aisle {        grid-column: 4;      }      .seat {        width: 40px;        height: 40px;        display: flex;        justify-content: center;        align-items: center;        border: 1px solid #ccc;        cursor: pointer;      }      .seat.available {        background-color: #5dbf61ba;        color: white;      }      .seat.unavailable {        background-color: #f4433673;        color: white;        cursor: not-allowed;      }      .airplane {        display: flex;        flex-direction: column;        align-items: center;        background-color: #f0f0f0;        padding: 20px;        border-radius: 20px;      }    </style>  </head>  <body>    <div class="booking-container">      <h2 id="title"></h2>      <div class="airplane">        <div id="seatGrid" class="seat-grid"></div>      </div>    </div>      <script>        const seatGrid = document.getElementById("seatGrid");        const title = document.getElementById("title");        const flightId = window.location.search.split("=")[1];        const hostname = window.location.hostname;        if (flightId === undefined) {          title.textContent = "No Flight ID provided";          seatGrid.innerHTML = "<p>Add `flightId` to the query string</p>";        } else {          handleBooking();        }        function handleBooking() {          let ws;          if (hostname === 'localhost') {            const port = window.location.port;            ws = new WebSocket(`ws://${hostname}:${port}/ws?flightId=${flightId}`);          } else {            ws = new WebSocket(`wss://${hostname}/ws?flightId=${flightId}`);          }          title.textContent = `Book seat for flight ${flightId}`;          ws.onopen = () => {            console.log("Connected to WebSocket server");          };          function createSeatGrid(seats) {            seatGrid.innerHTML = "";            for (let row = 1; row <= 10; row++) {              for (let col = 0; col < 6; col++) {                if (col === 3) {                  const aisle = document.createElement("div");                  aisle.className = "aisle";                  seatGrid.appendChild(aisle);                }                const seatNumber = `${row}${String.fromCharCode(65 + col)}`;                const seat = seats.find((s) => s.seatNumber === seatNumber);                const seatElement = document.createElement("div");                seatElement.className = `seat ${seat && seat.occupant ? "unavailable" : "available"}`;                seatElement.textContent = seatNumber;                seatElement.onclick = () => bookSeat(seatNumber);                seatGrid.appendChild(seatElement);              }            }          }          async function fetchSeats() {            const response = await fetch(`/seats?flightId=${flightId}`);            const seats = await response.json();            createSeatGrid(seats);          }          async function bookSeat(seatNumber) {            const name = prompt("Please enter your name:");            if (!name) {              return; // User canceled the prompt            }            const response = await fetch(`book-seat?flightId=${flightId}`, {              method: "POST",              headers: { "Content-Type": "application/json" },              body: JSON.stringify({ seatNumber, name }),            });            const result = await response.text();            fetchSeats();          }          ws.onmessage = (event) => {            try {              const seats = JSON.parse(event.data);              createSeatGrid(seats);            } catch (error) {              console.error("Error parsing WebSocket message:", error);            }          };          ws.onerror = (error) => {            console.error("WebSocket error:", error);          };          ws.onclose = (event) => {            console.log("WebSocket connection closed:", event);          };          fetchSeats();        }      </script>    </body></html>
    ```

    -   The frontend makes an HTTP `GET` request to the `/seats` endpoint to retrieve the available seats for the flight.
    -   It also uses a WebSocket connection to receive updates about the available seats.
    -   When a user clicks on a seat, the `bookSeat()` function is called that prompts the user to enter their name and then makes a `POST` request to the `/book-seat` endpoint.

    4.  Update the bindings in `wrangler.toml` to configure `assets` to serve the `public` directory.

    -   [wrangler.toml](#tab-panel-1588)
    -   [wrangler.json](#tab-panel-1589)

    ```
    [assets]directory = "public"
    ```

    5.  If you start the development server using the following command, the frontend will be served at `http://localhost:8787`. However, it will not work because the backend is not yet implemented.

    ## 3\. Create table for each flight

    The application already has the binding for the Durable Objects class configured in `wrangler.toml`. If you update the name of the Durable Objects class in `src/index.ts`, make sure to also update the binding in `wrangler.toml`.

    1.  Update the binding to use the SQLite storage in Durable Objects. In `wrangler.toml`, replace `new_classes=["Flight"]` with `new_sqlite_classes=["Flight"]`, `name = "FLIGHT"` with `name = "FLIGHT"`, and `class_name = "MyDurableObject"` with `class_name = "Flight"`. Your `wrangler.toml` should look like this:

    -   [wrangler.toml](#tab-panel-1590)
    -   [wrangler.json](#tab-panel-1591)

    ```
    [[durable_objects.bindings]]name = "FLIGHT"class_name = "Flight"# Durable Object migrations.# Docs: https://developers.cloudflare.com/workers/wrangler/configuration/#migrations[[migrations]]tag = "v1"new_sqlite_classes = ["Flight"]
    ```

    Your application can now use the SQLite storage in Durable Objects.

    2.  Add the `initializeSeats()` function to the `Flight` class. This function will be called when the Durable Object is initialized. It will check if the table exists, and if not, it will create it. It will also insert seats information in the table.

    For this tutorial, the function creates an identical seating plan for all the flights. However, in production, you would want to update this function to insert seats based on the flight type.

    Replace the `Flight` class with the following code:

    ```
    import { DurableObject } from "cloudflare:workers";export class Flight extends DurableObject {  sql = this.ctx.storage.sql;  constructor(ctx: DurableObjectState, env: Env) {    super(ctx, env);    this.initializeSeats();  }  private initializeSeats() {    const cursor = this.sql.exec(`PRAGMA table_list`);    // Check if a table exists.    if ([...cursor].find((t) => t.name === "seats")) {      console.log("Table already exists");      return;    }    this.sql.exec(`          CREATE TABLE IF NOT EXISTS seats (          seatId TEXT PRIMARY KEY,          occupant TEXT          )        `);    // For this demo, we populate the table with 60 seats.    // Since SQLite in DOs is fast, we can do a query per INSERT instead of batching them in a transaction.    for (let row = 1; row <= 10; row++) {      for (let col = 0; col < 6; col++) {        const seatNumber = `${row}${String.fromCharCode(65 + col)}`;        this.sql.exec(`INSERT INTO seats VALUES (?, null)`, seatNumber);      }    }  }}
    ```

    3.  Add a `fetch` handler to the `Flight` class. This handler will return a text response. In [Step 5](#5-handle-websocket-connections) You will update the `fetch` handler to handle the WebSocket connection.

    ```
    import { DurableObject } from "cloudflare:workers";export class Flight extends DurableObject {  ...  async fetch(request: Request): Promise<Response> {    return new Response("Hello from Durable Object!", { status: 200 });  }}
    ```

    4.  Next, update the Worker's fetch handler to create a unique Durable Object for each flight.

    ```
    export default {  async fetch(request, env, ctx): Promise<Response> {    // Get flight id from the query parameter    const url = new URL(request.url);    const flightId = url.searchParams.get("flightId");    if (!flightId) {      return new Response(        "Flight ID not found. Provide flightId in the query parameter",        { status: 404 },      );    }    const id = env.FLIGHT.idFromName(flightId);    const stub = env.FLIGHT.get(id);    return stub.fetch(request);  },} satisfies ExportedHandler<Env>;
    ```

    Using the flight ID, from the query parameter, a unique Durable Object is created. This Durable Object is initialized with a table if it does not exist.

    ## 4\. Add methods to the Durable Object

    1.  Add the `getSeats()` function to the `Flight` class. This function returns all the seats in the table.

    ```
    import { DurableObject } from "cloudflare:workers";export class Flight extends DurableObject {    ...  private initializeSeats() {    ...  }  // Get all seats.  getSeats() {    let results = [];    // Query returns a cursor.    let cursor = this.sql.exec(`SELECT seatId, occupant FROM seats`);    // Cursors are iterable.    for (let row of cursor) {      // Each row is an object with a property for each column.      results.push({ seatNumber: row.seatId, occupant: row.occupant });    }    return results;  }}
    ```

    2.  Add the `assignSeat()` function to the `Flight` class. This function will assign a seat to a passenger. It takes the seat number and the passenger name as parameters.

    ```
    import { DurableObject } from "cloudflare:workers";export class Flight extends DurableObject {  ...  private initializeSeats() {    ...  }  // Get all seats.  getSeats() {    ...  }  // Assign a seat to a passenger.  assignSeat(seatId: string, occupant: string) {    // Check that seat isn't occupied.    let cursor = this.sql.exec(      `SELECT occupant FROM seats WHERE seatId = ?`,      seatId,    );    let result = cursor.toArray()[0]; // Get the first result from the cursor.    if (!result) {      return {message: 'Seat not available',  status: 400 };    }    if (result.occupant !== null) {      return {message: 'Seat not available',  status: 400 };    }    // If the occupant is already in a different seat, remove them.    this.sql.exec(      `UPDATE seats SET occupant = null WHERE occupant = ?`,      occupant,    );    // Assign the seat. Note: We don't have to worry that a concurrent request may    // have grabbed the seat between the two queries, because the code is synchronous    // (no `await`s) and the database is private to this Durable Object. Nothing else    // could have changed since we checked that the seat was available earlier!    this.sql.exec(      `UPDATE seats SET occupant = ? WHERE seatId = ?`,      occupant,      seatId,    );    // Broadcast the updated seats.    this.broadcastSeats();    return {message: `Seat ${seatId} booked successfully`, status: 200 };  }}
    ```

    The above function uses the `broadcastSeats()` function to broadcast the updated seats to all the connected clients. In the next section, we will add the `broadcastSeats()` function.

    ## 5\. Handle WebSocket connections

    All the clients will connect to the Durable Object using WebSockets. The Durable Object will broadcast the updated seats to all the connected clients. This allows the clients to update the UI in real time.

    1.  Add the `handleWebSocket()` function to the `Flight` class. This function handles the WebSocket connections.

    ```
    import { DurableObject } from "cloudflare:workers";export class Flight extends DurableObject {  ...  private initializeSeats() {    ...  }  // Get all seats.  getSeats() {    ...  }  // Assign a seat to a passenger.  assignSeat(seatId: string, occupant: string) {    ...  }  private handleWebSocket(request: Request) {    console.log('WebSocket connection requested');    const [client, server] = Object.values(new WebSocketPair());    this.ctx.acceptWebSocket(server);    console.log('WebSocket connection established');    return new Response(null, { status: 101, webSocket: client });  }}
    ```

    2.  Add the `broadcastSeats()` function to the `Flight` class. This function will broadcast the updated seats to all the connected clients.

    ```
    import { DurableObject } from "cloudflare:workers";export class Flight extends DurableObject {  ...  private initializeSeats() {    ...  }  // Get all seats.  getSeats() {    ...  }  // Assign a seat to a passenger.  assignSeat(seatId: string, occupant: string) {    ...  }  private handleWebSocket(request: Request) {    ...  }  private broadcastSeats() {    this.ctx.getWebSockets().forEach((ws) => ws.send(this.getSeats()));  }}
    ```

    3.  Next, update the `fetch` handler in the `Flight` class. This handler will handle all the incoming requests from the Worker and handle the WebSocket connections using the `handleWebSocket()` method.

    ```
    import { DurableObject } from "cloudflare:workers";export class Flight extends DurableObject {  ...  private initializeSeats() {    ...  }  // Get all seats.  getSeats() {    ...  }  // Assign a seat to a passenger.  assignSeat(seatId: string, occupant: string) {    ...  }  private handleWebSocket(request: Request) {    ...  }  private broadcastSeats() {    ...  }  async fetch(request: Request) {    return this.handleWebSocket(request);  }}
    ```

    4.  Finally, update the `fetch` handler of the Worker.

    ```
    export default {  ...  async fetch(request, env, ctx): Promise<Response> {    // Get flight id from the query parameter    ...    if (request.method === "GET" && url.pathname === "/seats") {      return new Response(JSON.stringify(await stub.getSeats()), {        headers: { 'Content-Type': 'application/json' },      });    } else if (request.method === "POST" && url.pathname === "/book-seat") {      const { seatNumber, name } = (await request.json()) as {        seatNumber: string;        name: string;      };      const result = await stub.assignSeat(seatNumber, name);      return new Response(JSON.stringify(result));    } else if (request.headers.get("Upgrade") === "websocket") {      return stub.fetch(request);    }    return new Response("Not found", { status: 404 });  },} satisfies ExportedHandler<Env>;
    ```

    The `fetch` handler in the Worker now calls appropriate Durable Object function to handle the incoming request. If the request is a `GET` request to `/seats`, the Worker returns the seats from the Durable Object. If the request is a `POST` request to `/book-seat`, the Worker calls the `bookSeat` method of the Durable Object to assign the seat to the passenger. If the request is a WebSocket connection, the Durable Object handles the WebSocket connection.

    ## 6\. Test the application

    You can test the application locally by running the following command:

    This starts a local development server that runs the application. The application is served at `http://localhost:8787`.

    Navigate to the application at `http://localhost:8787` in your browser. Since the flight ID is not specified, the application displays an error message.

    Update the URL with the flight ID as `http://localhost:8787?flightId=1234`. The application displays the seats for the flight with the ID `1234`.

    ## 7\. Deploy the application

    To deploy the application, run the following command:

    ```
     ⛅️ wrangler 3.78.8-------------------🌀 Building list of assets...🌀 Starting asset upload...🌀 Found 1 new or modified file to upload. Proceeding with upload...+ /index.htmlUploaded 1 of 1 assets✨ Success! Uploaded 1 file (1.93 sec)Total Upload: 3.45 KiB / gzip: 1.39 KiBYour worker has access to the following bindings:- Durable Objects:  - FLIGHT: FlightUploaded seat-book (12.12 sec)Deployed seat-book triggers (5.54 sec)  [DEPLOYED_APP_LINK]Current Version ID: [BINDING_ID]
    ```

    Navigate to the `[DEPLOYED_APP_LINK]` to see the application. Again, remember to pass the flight ID as a query string parameter.

    ## Summary

    In this tutorial, you have:

    -   used the SQLite storage backend in Durable Objects to store the seats for a flight.
    -   created a Durable Object class to manage the seat booking.
    -   deployed the application to Cloudflare Workers!

    The full code for this tutorial is available on [GitHub ↗](https://github.com/harshil1712/seat-booking-app).

    ## Thank you for helping improve Cloudflare's documentation!
- title: Reference · Cloudflare Durable Objects docs
  content: |-
    # Reference · Cloudflare Durable Objects docs

    1.  [Products](/products/)

    3.  [Durable Objects](/durable-objects/)
    4.  [Reference](/durable-objects/reference/)

    -   [In-memory state in a Durable Object](/durable-objects/reference/in-memory-state/)
    -   [Durable Objects migrations](/durable-objects/reference/durable-objects-migrations/)
    -   [Data security](/durable-objects/reference/data-security/)
    -   [Data location](/durable-objects/reference/data-location/)
    -   [Environments](/durable-objects/reference/environments/)
    -   [Gradual Deployments](about:/workers/configuration/versions-and-deployments/gradual-deployments/#gradual-deployments-for-durable-objects)
    -   [Glossary](/durable-objects/reference/glossary/)

    ## Was this helpful?

    Yes No

    ## What did you like?

    Accurate

    Easy to understand

    Solved my problem

    Helped me decide to use the product

    Other

    ## What went wrong?

    Hard to understand

    Incorrect information

    Missing the information

    Other

    ## Thank you for helping improve Cloudflare's documentation!

    [Cloudflare Dashboard](https://dash.cloudflare.com/?to=/:account/workers)[Discord](https://discord.cloudflare.com/)[Community](https://community.cloudflare.com/)[Learning Center](https://www.cloudflare.com/learning/)[Support Portal](/support/contacting-cloudflare-support/)

    Cookie Settings
